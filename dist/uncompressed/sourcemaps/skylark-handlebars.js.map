{"version":3,"sources":["skylark-handlebars.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-handlebars.js","sourcesContent":["define('skylark-handlebars/utils',[],function () {\n    'use strict';\n    const escape = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#x27;',\n        '`': '&#x60;',\n        '=': '&#x3D;'\n    };\n    const badChars = /[&<>\"'`=]/g, possible = /[&<>\"'`=]/;\n    function escapeChar(chr) {\n        return escape[chr];\n    }\n    function extend(obj) {\n        for (let i = 1; i < arguments.length; i++) {\n            for (let key in arguments[i]) {\n                if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {\n                    obj[key] = arguments[i][key];\n                }\n            }\n        }\n        return obj;\n    }\n    let toString = Object.prototype.toString;\n    let isFunction = function (value) {\n        return typeof value === 'function';\n    };\n    if (isFunction(/x/)) {\n        isFunction = function (value) {\n            return typeof value === 'function' && toString.call(value) === '[object Function]';\n        };\n    }\n    const isArray = Array.isArray || function (value) {\n        return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;\n    };\n    function indexOf(array, value) {\n        for (let i = 0, len = array.length; i < len; i++) {\n            if (array[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    function escapeExpression(string) {\n        if (typeof string !== 'string') {\n            if (string && string.toHTML) {\n                return string.toHTML();\n            } else if (string == null) {\n                return '';\n            } else if (!string) {\n                return string + '';\n            }\n            string = '' + string;\n        }\n        if (!possible.test(string)) {\n            return string;\n        }\n        return string.replace(badChars, escapeChar);\n    }\n    function isEmpty(value) {\n        if (!value && value !== 0) {\n            return true;\n        } else if (isArray(value) && value.length === 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function createFrame(object) {\n        let frame = extend({}, object);\n        frame._parent = object;\n        return frame;\n    }\n    function blockParams(params, ids) {\n        params.path = ids;\n        return params;\n    }\n    function appendContextPath(contextPath, id) {\n        return (contextPath ? contextPath + '.' : '') + id;\n    }\n    return {\n        extend: extend,\n        toString: toString,\n        isFunction,\n        isArray: isArray,\n        indexOf: indexOf,\n        escapeExpression: escapeExpression,\n        isEmpty: isEmpty,\n        createFrame: createFrame,\n        blockParams: blockParams,\n        appendContextPath: appendContextPath\n    };\n});\ndefine('skylark-handlebars/exception',[],function () {\n    'use strict';\n    const errorProps = [\n        'description',\n        'fileName',\n        'lineNumber',\n        'endLineNumber',\n        'message',\n        'name',\n        'number',\n        'stack'\n    ];\n    function Exception(message, node) {\n        let loc = node && node.loc, line, endLineNumber, column, endColumn;\n        if (loc) {\n            line = loc.start.line;\n            endLineNumber = loc.end.line;\n            column = loc.start.column;\n            endColumn = loc.end.column;\n            message += ' - ' + line + ':' + column;\n        }\n        let tmp = Error.prototype.constructor.call(this, message);\n        for (let idx = 0; idx < errorProps.length; idx++) {\n            this[errorProps[idx]] = tmp[errorProps[idx]];\n        }\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, Exception);\n        }\n        try {\n            if (loc) {\n                this.lineNumber = line;\n                this.endLineNumber = endLineNumber;\n                if (Object.defineProperty) {\n                    Object.defineProperty(this, 'column', {\n                        value: column,\n                        enumerable: true\n                    });\n                    Object.defineProperty(this, 'endColumn', {\n                        value: endColumn,\n                        enumerable: true\n                    });\n                } else {\n                    this.column = column;\n                    this.endColumn = endColumn;\n                }\n            }\n        } catch (nop) {\n        }\n    }\n    Exception.prototype = new Error();\n    return Exception;\n});\ndefine('skylark-handlebars/helpers/block-helper-missing',['../utils'], function (utils) {\n    'use strict';\n    return function (instance) {\n        instance.registerHelper('blockHelperMissing', function (context, options) {\n            let inverse = options.inverse, fn = options.fn;\n            if (context === true) {\n                return fn(this);\n            } else if (context === false || context == null) {\n                return inverse(this);\n            } else if (utils.isArray(context)) {\n                if (context.length > 0) {\n                    if (options.ids) {\n                        options.ids = [options.name];\n                    }\n                    return instance.helpers.each(context, options);\n                } else {\n                    return inverse(this);\n                }\n            } else {\n                if (options.data && options.ids) {\n                    let data = utils.createFrame(options.data);\n                    data.contextPath = utils.appendContextPath(options.data.contextPath, options.name);\n                    options = { data: data };\n                }\n                return fn(context, options);\n            }\n        });\n    };\n});\ndefine('skylark-handlebars/helpers/each',[\n    '../utils',\n    '../exception'\n], function (utils, Exception) {\n    'use strict';\n    return function (instance) {\n        instance.registerHelper('each', function (context, options) {\n            if (!options) {\n                throw new Exception('Must pass iterator to #each');\n            }\n            let fn = options.fn, inverse = options.inverse, i = 0, ret = '', data, contextPath;\n            if (options.data && options.ids) {\n                contextPath = utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';\n            }\n            if (utils.isFunction(context)) {\n                context = context.call(this);\n            }\n            if (options.data) {\n                data = utils.createFrame(options.data);\n            }\n            function execIteration(field, index, last) {\n                if (data) {\n                    data.key = field;\n                    data.index = index;\n                    data.first = index === 0;\n                    data.last = !!last;\n                    if (contextPath) {\n                        data.contextPath = contextPath + field;\n                    }\n                }\n                ret = ret + fn(context[field], {\n                    data: data,\n                    blockParams: utils.blockParams([\n                        context[field],\n                        field\n                    ], [\n                        contextPath + field,\n                        null\n                    ])\n                });\n            }\n            if (context && typeof context === 'object') {\n                if (utils.isArray(context)) {\n                    for (let j = context.length; i < j; i++) {\n                        if (i in context) {\n                            execIteration(i, i, i === context.length - 1);\n                        }\n                    }\n                } else if (global.Symbol && context[global.Symbol.iterator]) {\n                    const newContext = [];\n                    const iterator = context[global.Symbol.iterator]();\n                    for (let it = iterator.next(); !it.done; it = iterator.next()) {\n                        newContext.push(it.value);\n                    }\n                    context = newContext;\n                    for (let j = context.length; i < j; i++) {\n                        execIteration(i, i, i === context.length - 1);\n                    }\n                } else {\n                    let priorKey;\n                    Object.keys(context).forEach(key => {\n                        if (priorKey !== undefined) {\n                            execIteration(priorKey, i - 1);\n                        }\n                        priorKey = key;\n                        i++;\n                    });\n                    if (priorKey !== undefined) {\n                        execIteration(priorKey, i - 1, true);\n                    }\n                }\n            }\n            if (i === 0) {\n                ret = inverse(this);\n            }\n            return ret;\n        });\n    };\n});\ndefine('skylark-handlebars/helpers/helper-missing',['../exception'], function (Exception) {\n    'use strict';\n    return function (instance) {\n        instance.registerHelper('helperMissing', function () {\n            if (arguments.length === 1) {\n                return undefined;\n            } else {\n                throw new Exception('Missing helper: \"' + arguments[arguments.length - 1].name + '\"');\n            }\n        });\n    };\n});\ndefine('skylark-handlebars/helpers/if',[\n    '../utils',\n    '../exception'\n], function (utils, Exception) {\n    'use strict';\n    return function (instance) {\n        instance.registerHelper('if', function (conditional, options) {\n            if (arguments.length != 2) {\n                throw new Exception('#if requires exactly one argument');\n            }\n            if (utils.isFunction(conditional)) {\n                conditional = conditional.call(this);\n            }\n            if (!options.hash.includeZero && !conditional || utils.isEmpty(conditional)) {\n                return options.inverse(this);\n            } else {\n                return options.fn(this);\n            }\n        });\n        instance.registerHelper('unless', function (conditional, options) {\n            if (arguments.length != 2) {\n                throw new Exception('#unless requires exactly one argument');\n            }\n            return instance.helpers['if'].call(this, conditional, {\n                fn: options.inverse,\n                inverse: options.fn,\n                hash: options.hash\n            });\n        });\n    };\n});\ndefine('skylark-handlebars/helpers/log',[],function () {\n    'use strict';\n    return function (instance) {\n        instance.registerHelper('log', function () {\n            let args = [undefined], options = arguments[arguments.length - 1];\n            for (let i = 0; i < arguments.length - 1; i++) {\n                args.push(arguments[i]);\n            }\n            let level = 1;\n            if (options.hash.level != null) {\n                level = options.hash.level;\n            } else if (options.data && options.data.level != null) {\n                level = options.data.level;\n            }\n            args[0] = level;\n            instance.log(...args);\n        });\n    };\n});\ndefine('skylark-handlebars/helpers/lookup',[],function () {\n    'use strict';\n    return function (instance) {\n        instance.registerHelper('lookup', function (obj, field, options) {\n            if (!obj) {\n                return obj;\n            }\n            return options.lookupProperty(obj, field);\n        });\n    };\n});\ndefine('skylark-handlebars/helpers/with',[\n    '../utils',\n    '../exception'\n], function (utils, Exception) {\n    'use strict';\n    return function (instance) {\n        instance.registerHelper('with', function (context, options) {\n            if (arguments.length != 2) {\n                throw new Exception('#with requires exactly one argument');\n            }\n            if (utils.isFunction(context)) {\n                context = context.call(this);\n            }\n            let fn = options.fn;\n            if (!utils.isEmpty(context)) {\n                let data = options.data;\n                if (options.data && options.ids) {\n                    data = utils.createFrame(options.data);\n                    data.contextPath = utils.appendContextPath(options.data.contextPath, options.ids[0]);\n                }\n                return fn(context, {\n                    data: data,\n                    blockParams: utils.blockParams([context], [data && data.contextPath])\n                });\n            } else {\n                return options.inverse(this);\n            }\n        });\n    };\n});\ndefine('skylark-handlebars/helpers',[\n    './helpers/block-helper-missing',\n    './helpers/each',\n    './helpers/helper-missing',\n    './helpers/if',\n    './helpers/log',\n    './helpers/lookup',\n    './helpers/with'\n], function (registerBlockHelperMissing, registerEach, registerHelperMissing, registerIf, registerLog, registerLookup, registerWith) {\n    'use strict';\n    function registerDefaultHelpers(instance) {\n        registerBlockHelperMissing(instance);\n        registerEach(instance);\n        registerHelperMissing(instance);\n        registerIf(instance);\n        registerLog(instance);\n        registerLookup(instance);\n        registerWith(instance);\n    }\n    function moveHelperToHooks(instance, helperName, keepHelper) {\n        if (instance.helpers[helperName]) {\n            instance.hooks[helperName] = instance.helpers[helperName];\n            if (!keepHelper) {\n                delete instance.helpers[helperName];\n            }\n        }\n    }\n    return {\n        registerDefaultHelpers: registerDefaultHelpers,\n        moveHelperToHooks: moveHelperToHooks\n    };\n});\ndefine('skylark-handlebars/decorators/inline',['../utils'], function (utils) {\n    'use strict';\n    return function (instance) {\n        instance.registerDecorator('inline', function (fn, props, container, options) {\n            let ret = fn;\n            if (!props.partials) {\n                props.partials = {};\n                ret = function (context, options) {\n                    let original = container.partials;\n                    container.partials = utils.extend({}, original, props.partials);\n                    let ret = fn(context, options);\n                    container.partials = original;\n                    return ret;\n                };\n            }\n            props.partials[options.args[0]] = options.fn;\n            return ret;\n        });\n    };\n});\ndefine('skylark-handlebars/decorators',['./decorators/inline'], function (registerInline) {\n    'use strict';\n    function registerDefaultDecorators(instance) {\n        registerInline(instance);\n    }\n    return { registerDefaultDecorators: registerDefaultDecorators };\n});\ndefine('skylark-handlebars/logger',['./utils'], function (utils) {\n    'use strict';\n    let logger = {\n        methodMap: [\n            'debug',\n            'info',\n            'warn',\n            'error'\n        ],\n        level: 'info',\n        lookupLevel: function (level) {\n            if (typeof level === 'string') {\n                let levelMap = utils.indexOf(logger.methodMap, level.toLowerCase());\n                if (levelMap >= 0) {\n                    level = levelMap;\n                } else {\n                    level = parseInt(level, 10);\n                }\n            }\n            return level;\n        },\n        log: function (level, ...message) {\n            level = logger.lookupLevel(level);\n            if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {\n                let method = logger.methodMap[level];\n                if (!console[method]) {\n                    method = 'log';\n                }\n                console[method](...message);\n            }\n        }\n    };\n    return logger;\n});\ndefine('skylark-handlebars/internal/create-new-lookup-object',['../utils'], function (utils) {\n    'use strict';\n    function createNewLookupObject(...sources) {\n        return utils.extend(Object.create(null), ...sources);\n    }\n    return { createNewLookupObject: createNewLookupObject };\n});\ndefine('skylark-handlebars/internal/proto-access',[\n    './create-new-lookup-object',\n    '../logger'\n], function (a, logger) {\n    'use strict';\n    const loggedProperties = Object.create(null);\n    function createProtoAccessControl(runtimeOptions) {\n        let defaultMethodWhiteList = Object.create(null);\n        defaultMethodWhiteList['constructor'] = false;\n        defaultMethodWhiteList['__defineGetter__'] = false;\n        defaultMethodWhiteList['__defineSetter__'] = false;\n        defaultMethodWhiteList['__lookupGetter__'] = false;\n        let defaultPropertyWhiteList = Object.create(null);\n        defaultPropertyWhiteList['__proto__'] = false;\n        return {\n            properties: {\n                whitelist: a.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),\n                defaultValue: runtimeOptions.allowProtoPropertiesByDefault\n            },\n            methods: {\n                whitelist: a.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),\n                defaultValue: runtimeOptions.allowProtoMethodsByDefault\n            }\n        };\n    }\n    function resultIsAllowed(result, protoAccessControl, propertyName) {\n        if (typeof result === 'function') {\n            return checkWhiteList(protoAccessControl.methods, propertyName);\n        } else {\n            return checkWhiteList(protoAccessControl.properties, propertyName);\n        }\n    }\n    function checkWhiteList(protoAccessControlForType, propertyName) {\n        if (protoAccessControlForType.whitelist[propertyName] !== undefined) {\n            return protoAccessControlForType.whitelist[propertyName] === true;\n        }\n        if (protoAccessControlForType.defaultValue !== undefined) {\n            return protoAccessControlForType.defaultValue;\n        }\n        logUnexpecedPropertyAccessOnce(propertyName);\n        return false;\n    }\n    function logUnexpecedPropertyAccessOnce(propertyName) {\n        if (loggedProperties[propertyName] !== true) {\n            loggedProperties[propertyName] = true;\n            logger.log('error', `Handlebars: Access has been denied to resolve the property \"${ propertyName }\" because it is not an \"own property\" of its parent.\\n` + `You can add a runtime option to disable the check or this warning:\\n` + `See https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details`);\n        }\n    }\n    function resetLoggedProperties() {\n        Object.keys(loggedProperties).forEach(propertyName => {\n            delete loggedProperties[propertyName];\n        });\n    }\n    return {\n        createProtoAccessControl: createProtoAccessControl,\n        resultIsAllowed: resultIsAllowed,\n        resetLoggedProperties: resetLoggedProperties\n    };\n});\ndefine('skylark-handlebars/base',[\n    './utils',\n    './exception',\n    './helpers',\n    './decorators',\n    './logger',\n    './internal/proto-access'\n], function (utils, Exception, b, c, logger, protoAccess) {\n    'use strict';\n    const VERSION = '4.7.6';\n    const COMPILER_REVISION = 8;\n    const LAST_COMPATIBLE_COMPILER_REVISION = 7;\n    const REVISION_CHANGES = {\n        1: '<= 1.0.rc.2',\n        2: '== 1.0.0-rc.3',\n        3: '== 1.0.0-rc.4',\n        4: '== 1.x.x',\n        5: '== 2.0.0-alpha.x',\n        6: '>= 2.0.0-beta.1',\n        7: '>= 4.0.0 <4.3.0',\n        8: '>= 4.3.0'\n    };\n    const objectType = '[object Object]';\n    function HandlebarsEnvironment(helpers, partials, decorators) {\n        this.helpers = helpers || {};\n        this.partials = partials || {};\n        this.decorators = decorators || {};\n        b.registerDefaultHelpers(this);\n        c.registerDefaultDecorators(this);\n    }\n    HandlebarsEnvironment.prototype = {\n        constructor: HandlebarsEnvironment,\n        logger: logger,\n        log: logger.log,\n        registerHelper: function (name, fn) {\n            if (utils.toString.call(name) === objectType) {\n                if (fn) {\n                    throw new Exception('Arg not supported with multiple helpers');\n                }\n                utils.extend(this.helpers, name);\n            } else {\n                this.helpers[name] = fn;\n            }\n        },\n        unregisterHelper: function (name) {\n            delete this.helpers[name];\n        },\n        registerPartial: function (name, partial) {\n            if (utils.toString.call(name) === objectType) {\n                utils.extend(this.partials, name);\n            } else {\n                if (typeof partial === 'undefined') {\n                    throw new Exception(`Attempting to register a partial called \"${ name }\" as undefined`);\n                }\n                this.partials[name] = partial;\n            }\n        },\n        unregisterPartial: function (name) {\n            delete this.partials[name];\n        },\n        registerDecorator: function (name, fn) {\n            if (utils.toString.call(name) === objectType) {\n                if (fn) {\n                    throw new Exception('Arg not supported with multiple decorators');\n                }\n                utils.extend(this.decorators, name);\n            } else {\n                this.decorators[name] = fn;\n            }\n        },\n        unregisterDecorator: function (name) {\n            delete this.decorators[name];\n        },\n        resetLoggedPropertyAccesses: function () {\n            protoAccess.resetLoggedProperties();\n        }\n    };\n    let log = logger.log,\n        createFrame = utils.createFrame;\n    return {\n        VERSION,\n        COMPILER_REVISION,\n        LAST_COMPATIBLE_COMPILER_REVISION,\n        REVISION_CHANGES,\n        HandlebarsEnvironment,\n        log,\n        createFrame,\n        logger\n    };\n});\ndefine('skylark-handlebars/internal/wrapHelper',[],function () {\n    'use strict';\n    function wrapHelper(helper, transformOptionsFn) {\n        if (typeof helper !== 'function') {\n            return helper;\n        }\n        let wrapper = function () {\n            const options = arguments[arguments.length - 1];\n            arguments[arguments.length - 1] = transformOptionsFn(options);\n            return helper.apply(this, arguments);\n        };\n        return wrapper;\n    }\n    return { wrapHelper: wrapHelper };\n});\ndefine('skylark-handlebars/runtime',[\n    './utils',\n    './exception',\n    './base',\n    './helpers',\n    './internal/wrapHelper',\n    './internal/proto-access'\n], function (Utils, Exception, a, b, c, d) {\n    'use strict';\n    function checkRevision(compilerInfo) {\n        const compilerRevision = compilerInfo && compilerInfo[0] || 1, currentRevision = a.COMPILER_REVISION;\n        if (compilerRevision >= a.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= a.COMPILER_REVISION) {\n            return;\n        }\n        if (compilerRevision < a.LAST_COMPATIBLE_COMPILER_REVISION) {\n            const runtimeVersions = a.REVISION_CHANGES[currentRevision], compilerVersions = a.REVISION_CHANGES[compilerRevision];\n            throw new Exception('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');\n        } else {\n            throw new Exception('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');\n        }\n    }\n    function template(templateSpec, env) {\n        if (!env) {\n            throw new Exception('No environment passed to template');\n        }\n        if (!templateSpec || !templateSpec.main) {\n            throw new Exception('Unknown template object: ' + typeof templateSpec);\n        }\n        templateSpec.main.decorator = templateSpec.main_d;\n        env.VM.checkRevision(templateSpec.compiler);\n        const templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;\n        function invokePartialWrapper(partial, context, options) {\n            if (options.hash) {\n                context = Utils.extend({}, context, options.hash);\n                if (options.ids) {\n                    options.ids[0] = true;\n                }\n            }\n            partial = env.VM.resolvePartial.call(this, partial, context, options);\n            let extendedOptions = Utils.extend({}, options, {\n                hooks: this.hooks,\n                protoAccessControl: this.protoAccessControl\n            });\n            let result = env.VM.invokePartial.call(this, partial, context, extendedOptions);\n            if (result == null && env.compile) {\n                options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);\n                result = options.partials[options.name](context, extendedOptions);\n            }\n            if (result != null) {\n                if (options.indent) {\n                    let lines = result.split('\\n');\n                    for (let i = 0, l = lines.length; i < l; i++) {\n                        if (!lines[i] && i + 1 === l) {\n                            break;\n                        }\n                        lines[i] = options.indent + lines[i];\n                    }\n                    result = lines.join('\\n');\n                }\n                return result;\n            } else {\n                throw new Exception('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');\n            }\n        }\n        let container = {\n            strict: function (obj, name, loc) {\n                if (!obj || !(name in obj)) {\n                    throw new Exception('\"' + name + '\" not defined in ' + obj, { loc: loc });\n                }\n                return obj[name];\n            },\n            lookupProperty: function (parent, propertyName) {\n                let result = parent[propertyName];\n                if (result == null) {\n                    return result;\n                }\n                if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n                    return result;\n                }\n                if (d.resultIsAllowed(result, container.protoAccessControl, propertyName)) {\n                    return result;\n                }\n                return undefined;\n            },\n            lookup: function (depths, name) {\n                const len = depths.length;\n                for (let i = 0; i < len; i++) {\n                    let result = depths[i] && container.lookupProperty(depths[i], name);\n                    if (result != null) {\n                        return depths[i][name];\n                    }\n                }\n            },\n            lambda: function (current, context) {\n                return typeof current === 'function' ? current.call(context) : current;\n            },\n            escapeExpression: Utils.escapeExpression,\n            invokePartial: invokePartialWrapper,\n            fn: function (i) {\n                let ret = templateSpec[i];\n                ret.decorator = templateSpec[i + '_d'];\n                return ret;\n            },\n            programs: [],\n            program: function (i, data, declaredBlockParams, blockParams, depths) {\n                let programWrapper = this.programs[i], fn = this.fn(i);\n                if (data || depths || blockParams || declaredBlockParams) {\n                    programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);\n                } else if (!programWrapper) {\n                    programWrapper = this.programs[i] = wrapProgram(this, i, fn);\n                }\n                return programWrapper;\n            },\n            data: function (value, depth) {\n                while (value && depth--) {\n                    value = value._parent;\n                }\n                return value;\n            },\n            mergeIfNeeded: function (param, common) {\n                let obj = param || common;\n                if (param && common && param !== common) {\n                    obj = Utils.extend({}, common, param);\n                }\n                return obj;\n            },\n            nullContext: Object.seal({}),\n            noop: env.VM.noop,\n            compilerInfo: templateSpec.compiler\n        };\n        function ret(context, options = {}) {\n            let data = options.data;\n            ret._setup(options);\n            if (!options.partial && templateSpec.useData) {\n                data = initData(context, data);\n            }\n            let depths, blockParams = templateSpec.useBlockParams ? [] : undefined;\n            if (templateSpec.useDepths) {\n                if (options.depths) {\n                    depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;\n                } else {\n                    depths = [context];\n                }\n            }\n            function main(context) {\n                return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);\n            }\n            main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);\n            return main(context, options);\n        }\n        ret.isTop = true;\n        ret._setup = function (options) {\n            if (!options.partial) {\n                let mergedHelpers = Utils.extend({}, env.helpers, options.helpers);\n                wrapHelpersToPassLookupProperty(mergedHelpers, container);\n                container.helpers = mergedHelpers;\n                if (templateSpec.usePartial) {\n                    container.partials = container.mergeIfNeeded(options.partials, env.partials);\n                }\n                if (templateSpec.usePartial || templateSpec.useDecorators) {\n                    container.decorators = Utils.extend({}, env.decorators, options.decorators);\n                }\n                container.hooks = {};\n                container.protoAccessControl = d.createProtoAccessControl(options);\n                let keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;\n                b.moveHelperToHooks(container, 'helperMissing', keepHelperInHelpers);\n                b.moveHelperToHooks(container, 'blockHelperMissing', keepHelperInHelpers);\n            } else {\n                container.protoAccessControl = options.protoAccessControl;\n                container.helpers = options.helpers;\n                container.partials = options.partials;\n                container.decorators = options.decorators;\n                container.hooks = options.hooks;\n            }\n        };\n        ret._child = function (i, data, blockParams, depths) {\n            if (templateSpec.useBlockParams && !blockParams) {\n                throw new Exception('must pass block params');\n            }\n            if (templateSpec.useDepths && !depths) {\n                throw new Exception('must pass parent depths');\n            }\n            return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);\n        };\n        return ret;\n    }\n    function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {\n        function prog(context, options = {}) {\n            let currentDepths = depths;\n            if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {\n                currentDepths = [context].concat(depths);\n            }\n            return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);\n        }\n        prog = executeDecorators(fn, prog, container, depths, data, blockParams);\n        prog.program = i;\n        prog.depth = depths ? depths.length : 0;\n        prog.blockParams = declaredBlockParams || 0;\n        return prog;\n    }\n    function resolvePartial(partial, context, options) {\n        if (!partial) {\n            if (options.name === '@partial-block') {\n                partial = options.data['partial-block'];\n            } else {\n                partial = options.partials[options.name];\n            }\n        } else if (!partial.call && !options.name) {\n            options.name = partial;\n            partial = options.partials[partial];\n        }\n        return partial;\n    }\n    function invokePartial(partial, context, options) {\n        const currentPartialBlock = options.data && options.data['partial-block'];\n        options.partial = true;\n        if (options.ids) {\n            options.data.contextPath = options.ids[0] || options.data.contextPath;\n        }\n        let partialBlock;\n        if (options.fn && options.fn !== noop) {\n            options.data = a.createFrame(options.data);\n            let fn = options.fn;\n            partialBlock = options.data['partial-block'] = function partialBlockWrapper(context, options = {}) {\n                options.data = a.createFrame(options.data);\n                options.data['partial-block'] = currentPartialBlock;\n                return fn(context, options);\n            };\n            if (fn.partials) {\n                options.partials = Utils.extend({}, options.partials, fn.partials);\n            }\n        }\n        if (partial === undefined && partialBlock) {\n            partial = partialBlock;\n        }\n        if (partial === undefined) {\n            throw new Exception('The partial ' + options.name + ' could not be found');\n        } else if (partial instanceof Function) {\n            return partial(context, options);\n        }\n    }\n    function noop() {\n        return '';\n    }\n    function initData(context, data) {\n        if (!data || !('root' in data)) {\n            data = data ? a.createFrame(data) : {};\n            data.root = context;\n        }\n        return data;\n    }\n    function executeDecorators(fn, prog, container, depths, data, blockParams) {\n        if (fn.decorator) {\n            let props = {};\n            prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);\n            Utils.extend(prog, props);\n        }\n        return prog;\n    }\n    function wrapHelpersToPassLookupProperty(mergedHelpers, container) {\n        Object.keys(mergedHelpers).forEach(helperName => {\n            let helper = mergedHelpers[helperName];\n            mergedHelpers[helperName] = passLookupPropertyOption(helper, container);\n        });\n    }\n    function passLookupPropertyOption(helper, container) {\n        const lookupProperty = container.lookupProperty;\n        return c.wrapHelper(helper, options => {\n            return Utils.extend({ lookupProperty }, options);\n        });\n    }\n    return {\n        checkRevision: checkRevision,\n        template: template,\n        wrapProgram: wrapProgram,\n        resolvePartial: resolvePartial,\n        invokePartial: invokePartial,\n        noop: noop\n    };\n});\ndefine('skylark-handlebars/safe-string',[],function () {\n    'use strict';\n    function SafeString(string) {\n        this.string = string;\n    }\n    SafeString.prototype.toString = SafeString.prototype.toHTML = function () {\n        return '' + this.string;\n    };\n    return SafeString;\n});\ndefine('skylark-handlebars/compiler/ast',[],function () {\n    'use strict';\n    let AST = {\n        helpers: {\n            helperExpression: function (node) {\n                return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);\n            },\n            scopedId: function (path) {\n                return /^\\.|this\\b/.test(path.original);\n            },\n            simpleId: function (path) {\n                return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;\n            }\n        }\n    };\n    return AST;\n});\ndefine('skylark-handlebars/compiler/parser',[],function(){\r\n\r\n\t// File ignored in coverage tests via setting in .istanbul.yml\r\n\t/* Jison generated parser */\r\n\t\"use strict\";\r\n\tvar handlebars = (function () {\r\n\t    var parser = { trace: function trace() {},\r\n\t        yy: {},\r\n\t        symbols_: { \"error\": 2, \"root\": 3, \"program\": 4, \"EOF\": 5, \"program_repetition0\": 6, \"statement\": 7, \"mustache\": 8, \"block\": 9, \"rawBlock\": 10, \"partial\": 11, \"partialBlock\": 12, \"content\": 13, \"COMMENT\": 14, \"CONTENT\": 15, \"openRawBlock\": 16, \"rawBlock_repetition0\": 17, \"END_RAW_BLOCK\": 18, \"OPEN_RAW_BLOCK\": 19, \"helperName\": 20, \"openRawBlock_repetition0\": 21, \"openRawBlock_option0\": 22, \"CLOSE_RAW_BLOCK\": 23, \"openBlock\": 24, \"block_option0\": 25, \"closeBlock\": 26, \"openInverse\": 27, \"block_option1\": 28, \"OPEN_BLOCK\": 29, \"openBlock_repetition0\": 30, \"openBlock_option0\": 31, \"openBlock_option1\": 32, \"CLOSE\": 33, \"OPEN_INVERSE\": 34, \"openInverse_repetition0\": 35, \"openInverse_option0\": 36, \"openInverse_option1\": 37, \"openInverseChain\": 38, \"OPEN_INVERSE_CHAIN\": 39, \"openInverseChain_repetition0\": 40, \"openInverseChain_option0\": 41, \"openInverseChain_option1\": 42, \"inverseAndProgram\": 43, \"INVERSE\": 44, \"inverseChain\": 45, \"inverseChain_option0\": 46, \"OPEN_ENDBLOCK\": 47, \"OPEN\": 48, \"mustache_repetition0\": 49, \"mustache_option0\": 50, \"OPEN_UNESCAPED\": 51, \"mustache_repetition1\": 52, \"mustache_option1\": 53, \"CLOSE_UNESCAPED\": 54, \"OPEN_PARTIAL\": 55, \"partialName\": 56, \"partial_repetition0\": 57, \"partial_option0\": 58, \"openPartialBlock\": 59, \"OPEN_PARTIAL_BLOCK\": 60, \"openPartialBlock_repetition0\": 61, \"openPartialBlock_option0\": 62, \"param\": 63, \"sexpr\": 64, \"OPEN_SEXPR\": 65, \"sexpr_repetition0\": 66, \"sexpr_option0\": 67, \"CLOSE_SEXPR\": 68, \"hash\": 69, \"hash_repetition_plus0\": 70, \"hashSegment\": 71, \"ID\": 72, \"EQUALS\": 73, \"blockParams\": 74, \"OPEN_BLOCK_PARAMS\": 75, \"blockParams_repetition_plus0\": 76, \"CLOSE_BLOCK_PARAMS\": 77, \"path\": 78, \"dataName\": 79, \"STRING\": 80, \"NUMBER\": 81, \"BOOLEAN\": 82, \"UNDEFINED\": 83, \"NULL\": 84, \"DATA\": 85, \"pathSegments\": 86, \"SEP\": 87, \"$accept\": 0, \"$end\": 1 },\r\n\t        terminals_: { 2: \"error\", 5: \"EOF\", 14: \"COMMENT\", 15: \"CONTENT\", 18: \"END_RAW_BLOCK\", 19: \"OPEN_RAW_BLOCK\", 23: \"CLOSE_RAW_BLOCK\", 29: \"OPEN_BLOCK\", 33: \"CLOSE\", 34: \"OPEN_INVERSE\", 39: \"OPEN_INVERSE_CHAIN\", 44: \"INVERSE\", 47: \"OPEN_ENDBLOCK\", 48: \"OPEN\", 51: \"OPEN_UNESCAPED\", 54: \"CLOSE_UNESCAPED\", 55: \"OPEN_PARTIAL\", 60: \"OPEN_PARTIAL_BLOCK\", 65: \"OPEN_SEXPR\", 68: \"CLOSE_SEXPR\", 72: \"ID\", 73: \"EQUALS\", 75: \"OPEN_BLOCK_PARAMS\", 77: \"CLOSE_BLOCK_PARAMS\", 80: \"STRING\", 81: \"NUMBER\", 82: \"BOOLEAN\", 83: \"UNDEFINED\", 84: \"NULL\", 85: \"DATA\", 87: \"SEP\" },\r\n\t        productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],\r\n\t        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {\r\n\r\n\t            var $0 = $$.length - 1;\r\n\t            switch (yystate) {\r\n\t                case 1:\r\n\t                    return $$[$0 - 1];\r\n\t                    break;\r\n\t                case 2:\r\n\t                    this.$ = yy.prepareProgram($$[$0]);\r\n\t                    break;\r\n\t                case 3:\r\n\t                    this.$ = $$[$0];\r\n\t                    break;\r\n\t                case 4:\r\n\t                    this.$ = $$[$0];\r\n\t                    break;\r\n\t                case 5:\r\n\t                    this.$ = $$[$0];\r\n\t                    break;\r\n\t                case 6:\r\n\t                    this.$ = $$[$0];\r\n\t                    break;\r\n\t                case 7:\r\n\t                    this.$ = $$[$0];\r\n\t                    break;\r\n\t                case 8:\r\n\t                    this.$ = $$[$0];\r\n\t                    break;\r\n\t                case 9:\r\n\t                    this.$ = {\r\n\t                        type: 'CommentStatement',\r\n\t                        value: yy.stripComment($$[$0]),\r\n\t                        strip: yy.stripFlags($$[$0], $$[$0]),\r\n\t                        loc: yy.locInfo(this._$)\r\n\t                    };\r\n\r\n\t                    break;\r\n\t                case 10:\r\n\t                    this.$ = {\r\n\t                        type: 'ContentStatement',\r\n\t                        original: $$[$0],\r\n\t                        value: $$[$0],\r\n\t                        loc: yy.locInfo(this._$)\r\n\t                    };\r\n\r\n\t                    break;\r\n\t                case 11:\r\n\t                    this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);\r\n\t                    break;\r\n\t                case 12:\r\n\t                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };\r\n\t                    break;\r\n\t                case 13:\r\n\t                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);\r\n\t                    break;\r\n\t                case 14:\r\n\t                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);\r\n\t                    break;\r\n\t                case 15:\r\n\t                    this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };\r\n\t                    break;\r\n\t                case 16:\r\n\t                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };\r\n\t                    break;\r\n\t                case 17:\r\n\t                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };\r\n\t                    break;\r\n\t                case 18:\r\n\t                    this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };\r\n\t                    break;\r\n\t                case 19:\r\n\t                    var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),\r\n\t                        program = yy.prepareProgram([inverse], $$[$0 - 1].loc);\r\n\t                    program.chained = true;\r\n\r\n\t                    this.$ = { strip: $$[$0 - 2].strip, program: program, chain: true };\r\n\r\n\t                    break;\r\n\t                case 20:\r\n\t                    this.$ = $$[$0];\r\n\t                    break;\r\n\t                case 21:\r\n\t                    this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };\r\n\t                    break;\r\n\t                case 22:\r\n\t                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);\r\n\t                    break;\r\n\t                case 23:\r\n\t                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);\r\n\t                    break;\r\n\t                case 24:\r\n\t                    this.$ = {\r\n\t                        type: 'PartialStatement',\r\n\t                        name: $$[$0 - 3],\r\n\t                        params: $$[$0 - 2],\r\n\t                        hash: $$[$0 - 1],\r\n\t                        indent: '',\r\n\t                        strip: yy.stripFlags($$[$0 - 4], $$[$0]),\r\n\t                        loc: yy.locInfo(this._$)\r\n\t                    };\r\n\r\n\t                    break;\r\n\t                case 25:\r\n\t                    this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);\r\n\t                    break;\r\n\t                case 26:\r\n\t                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };\r\n\t                    break;\r\n\t                case 27:\r\n\t                    this.$ = $$[$0];\r\n\t                    break;\r\n\t                case 28:\r\n\t                    this.$ = $$[$0];\r\n\t                    break;\r\n\t                case 29:\r\n\t                    this.$ = {\r\n\t                        type: 'SubExpression',\r\n\t                        path: $$[$0 - 3],\r\n\t                        params: $$[$0 - 2],\r\n\t                        hash: $$[$0 - 1],\r\n\t                        loc: yy.locInfo(this._$)\r\n\t                    };\r\n\r\n\t                    break;\r\n\t                case 30:\r\n\t                    this.$ = { type: 'Hash', pairs: $$[$0], loc: yy.locInfo(this._$) };\r\n\t                    break;\r\n\t                case 31:\r\n\t                    this.$ = { type: 'HashPair', key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };\r\n\t                    break;\r\n\t                case 32:\r\n\t                    this.$ = yy.id($$[$0 - 1]);\r\n\t                    break;\r\n\t                case 33:\r\n\t                    this.$ = $$[$0];\r\n\t                    break;\r\n\t                case 34:\r\n\t                    this.$ = $$[$0];\r\n\t                    break;\r\n\t                case 35:\r\n\t                    this.$ = { type: 'StringLiteral', value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };\r\n\t                    break;\r\n\t                case 36:\r\n\t                    this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };\r\n\t                    break;\r\n\t                case 37:\r\n\t                    this.$ = { type: 'BooleanLiteral', value: $$[$0] === 'true', original: $$[$0] === 'true', loc: yy.locInfo(this._$) };\r\n\t                    break;\r\n\t                case 38:\r\n\t                    this.$ = { type: 'UndefinedLiteral', original: undefined, value: undefined, loc: yy.locInfo(this._$) };\r\n\t                    break;\r\n\t                case 39:\r\n\t                    this.$ = { type: 'NullLiteral', original: null, value: null, loc: yy.locInfo(this._$) };\r\n\t                    break;\r\n\t                case 40:\r\n\t                    this.$ = $$[$0];\r\n\t                    break;\r\n\t                case 41:\r\n\t                    this.$ = $$[$0];\r\n\t                    break;\r\n\t                case 42:\r\n\t                    this.$ = yy.preparePath(true, $$[$0], this._$);\r\n\t                    break;\r\n\t                case 43:\r\n\t                    this.$ = yy.preparePath(false, $$[$0], this._$);\r\n\t                    break;\r\n\t                case 44:\r\n\t                    $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });this.$ = $$[$0 - 2];\r\n\t                    break;\r\n\t                case 45:\r\n\t                    this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];\r\n\t                    break;\r\n\t                case 46:\r\n\t                    this.$ = [];\r\n\t                    break;\r\n\t                case 47:\r\n\t                    $$[$0 - 1].push($$[$0]);\r\n\t                    break;\r\n\t                case 48:\r\n\t                    this.$ = [];\r\n\t                    break;\r\n\t                case 49:\r\n\t                    $$[$0 - 1].push($$[$0]);\r\n\t                    break;\r\n\t                case 50:\r\n\t                    this.$ = [];\r\n\t                    break;\r\n\t                case 51:\r\n\t                    $$[$0 - 1].push($$[$0]);\r\n\t                    break;\r\n\t                case 58:\r\n\t                    this.$ = [];\r\n\t                    break;\r\n\t                case 59:\r\n\t                    $$[$0 - 1].push($$[$0]);\r\n\t                    break;\r\n\t                case 64:\r\n\t                    this.$ = [];\r\n\t                    break;\r\n\t                case 65:\r\n\t                    $$[$0 - 1].push($$[$0]);\r\n\t                    break;\r\n\t                case 70:\r\n\t                    this.$ = [];\r\n\t                    break;\r\n\t                case 71:\r\n\t                    $$[$0 - 1].push($$[$0]);\r\n\t                    break;\r\n\t                case 78:\r\n\t                    this.$ = [];\r\n\t                    break;\r\n\t                case 79:\r\n\t                    $$[$0 - 1].push($$[$0]);\r\n\t                    break;\r\n\t                case 82:\r\n\t                    this.$ = [];\r\n\t                    break;\r\n\t                case 83:\r\n\t                    $$[$0 - 1].push($$[$0]);\r\n\t                    break;\r\n\t                case 86:\r\n\t                    this.$ = [];\r\n\t                    break;\r\n\t                case 87:\r\n\t                    $$[$0 - 1].push($$[$0]);\r\n\t                    break;\r\n\t                case 90:\r\n\t                    this.$ = [];\r\n\t                    break;\r\n\t                case 91:\r\n\t                    $$[$0 - 1].push($$[$0]);\r\n\t                    break;\r\n\t                case 94:\r\n\t                    this.$ = [];\r\n\t                    break;\r\n\t                case 95:\r\n\t                    $$[$0 - 1].push($$[$0]);\r\n\t                    break;\r\n\t                case 98:\r\n\t                    this.$ = [$$[$0]];\r\n\t                    break;\r\n\t                case 99:\r\n\t                    $$[$0 - 1].push($$[$0]);\r\n\t                    break;\r\n\t                case 100:\r\n\t                    this.$ = [$$[$0]];\r\n\t                    break;\r\n\t                case 101:\r\n\t                    $$[$0 - 1].push($$[$0]);\r\n\t                    break;\r\n\t            }\r\n\t        },\r\n\t        table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],\r\n\t        defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] },\r\n\t        parseError: function parseError(str, hash) {\r\n\t            throw new Error(str);\r\n\t        },\r\n\t        parse: function parse(input) {\r\n\t            var self = this,\r\n\t                stack = [0],\r\n\t                vstack = [null],\r\n\t                lstack = [],\r\n\t                table = this.table,\r\n\t                yytext = \"\",\r\n\t                yylineno = 0,\r\n\t                yyleng = 0,\r\n\t                recovering = 0,\r\n\t                TERROR = 2,\r\n\t                EOF = 1;\r\n\t            this.lexer.setInput(input);\r\n\t            this.lexer.yy = this.yy;\r\n\t            this.yy.lexer = this.lexer;\r\n\t            this.yy.parser = this;\r\n\t            if (typeof this.lexer.yylloc == \"undefined\") this.lexer.yylloc = {};\r\n\t            var yyloc = this.lexer.yylloc;\r\n\t            lstack.push(yyloc);\r\n\t            var ranges = this.lexer.options && this.lexer.options.ranges;\r\n\t            if (typeof this.yy.parseError === \"function\") this.parseError = this.yy.parseError;\r\n\t            function popStack(n) {\r\n\t                stack.length = stack.length - 2 * n;\r\n\t                vstack.length = vstack.length - n;\r\n\t                lstack.length = lstack.length - n;\r\n\t            }\r\n\t            function lex() {\r\n\t                var token;\r\n\t                token = self.lexer.lex() || 1;\r\n\t                if (typeof token !== \"number\") {\r\n\t                    token = self.symbols_[token] || token;\r\n\t                }\r\n\t                return token;\r\n\t            }\r\n\t            var symbol,\r\n\t                preErrorSymbol,\r\n\t                state,\r\n\t                action,\r\n\t                a,\r\n\t                r,\r\n\t                yyval = {},\r\n\t                p,\r\n\t                len,\r\n\t                newState,\r\n\t                expected;\r\n\t            while (true) {\r\n\t                state = stack[stack.length - 1];\r\n\t                if (this.defaultActions[state]) {\r\n\t                    action = this.defaultActions[state];\r\n\t                } else {\r\n\t                    if (symbol === null || typeof symbol == \"undefined\") {\r\n\t                        symbol = lex();\r\n\t                    }\r\n\t                    action = table[state] && table[state][symbol];\r\n\t                }\r\n\t                if (typeof action === \"undefined\" || !action.length || !action[0]) {\r\n\t                    var errStr = \"\";\r\n\t                    if (!recovering) {\r\n\t                        expected = [];\r\n\t                        for (p in table[state]) if (this.terminals_[p] && p > 2) {\r\n\t                            expected.push(\"'\" + this.terminals_[p] + \"'\");\r\n\t                        }\r\n\t                        if (this.lexer.showPosition) {\r\n\t                            errStr = \"Parse error on line \" + (yylineno + 1) + \":\\n\" + this.lexer.showPosition() + \"\\nExpecting \" + expected.join(\", \") + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\r\n\t                        } else {\r\n\t                            errStr = \"Parse error on line \" + (yylineno + 1) + \": Unexpected \" + (symbol == 1 ? \"end of input\" : \"'\" + (this.terminals_[symbol] || symbol) + \"'\");\r\n\t                        }\r\n\t                        this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });\r\n\t                    }\r\n\t                }\r\n\t                if (action[0] instanceof Array && action.length > 1) {\r\n\t                    throw new Error(\"Parse Error: multiple actions possible at state: \" + state + \", token: \" + symbol);\r\n\t                }\r\n\t                switch (action[0]) {\r\n\t                    case 1:\r\n\t                        stack.push(symbol);\r\n\t                        vstack.push(this.lexer.yytext);\r\n\t                        lstack.push(this.lexer.yylloc);\r\n\t                        stack.push(action[1]);\r\n\t                        symbol = null;\r\n\t                        if (!preErrorSymbol) {\r\n\t                            yyleng = this.lexer.yyleng;\r\n\t                            yytext = this.lexer.yytext;\r\n\t                            yylineno = this.lexer.yylineno;\r\n\t                            yyloc = this.lexer.yylloc;\r\n\t                            if (recovering > 0) recovering--;\r\n\t                        } else {\r\n\t                            symbol = preErrorSymbol;\r\n\t                            preErrorSymbol = null;\r\n\t                        }\r\n\t                        break;\r\n\t                    case 2:\r\n\t                        len = this.productions_[action[1]][1];\r\n\t                        yyval.$ = vstack[vstack.length - len];\r\n\t                        yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };\r\n\t                        if (ranges) {\r\n\t                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];\r\n\t                        }\r\n\t                        r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\r\n\t                        if (typeof r !== \"undefined\") {\r\n\t                            return r;\r\n\t                        }\r\n\t                        if (len) {\r\n\t                            stack = stack.slice(0, -1 * len * 2);\r\n\t                            vstack = vstack.slice(0, -1 * len);\r\n\t                            lstack = lstack.slice(0, -1 * len);\r\n\t                        }\r\n\t                        stack.push(this.productions_[action[1]][0]);\r\n\t                        vstack.push(yyval.$);\r\n\t                        lstack.push(yyval._$);\r\n\t                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\r\n\t                        stack.push(newState);\r\n\t                        break;\r\n\t                    case 3:\r\n\t                        return true;\r\n\t                }\r\n\t            }\r\n\t            return true;\r\n\t        }\r\n\t    };\r\n\t    /* Jison generated lexer */\r\n\t    var lexer = (function () {\r\n\t        var lexer = { EOF: 1,\r\n\t            parseError: function parseError(str, hash) {\r\n\t                if (this.yy.parser) {\r\n\t                    this.yy.parser.parseError(str, hash);\r\n\t                } else {\r\n\t                    throw new Error(str);\r\n\t                }\r\n\t            },\r\n\t            setInput: function setInput(input) {\r\n\t                this._input = input;\r\n\t                this._more = this._less = this.done = false;\r\n\t                this.yylineno = this.yyleng = 0;\r\n\t                this.yytext = this.matched = this.match = '';\r\n\t                this.conditionStack = ['INITIAL'];\r\n\t                this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };\r\n\t                if (this.options.ranges) this.yylloc.range = [0, 0];\r\n\t                this.offset = 0;\r\n\t                return this;\r\n\t            },\r\n\t            input: function input() {\r\n\t                var ch = this._input[0];\r\n\t                this.yytext += ch;\r\n\t                this.yyleng++;\r\n\t                this.offset++;\r\n\t                this.match += ch;\r\n\t                this.matched += ch;\r\n\t                var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\r\n\t                if (lines) {\r\n\t                    this.yylineno++;\r\n\t                    this.yylloc.last_line++;\r\n\t                } else {\r\n\t                    this.yylloc.last_column++;\r\n\t                }\r\n\t                if (this.options.ranges) this.yylloc.range[1]++;\r\n\r\n\t                this._input = this._input.slice(1);\r\n\t                return ch;\r\n\t            },\r\n\t            unput: function unput(ch) {\r\n\t                var len = ch.length;\r\n\t                var lines = ch.split(/(?:\\r\\n?|\\n)/g);\r\n\r\n\t                this._input = ch + this._input;\r\n\t                this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);\r\n\t                //this.yyleng -= len;\r\n\t                this.offset -= len;\r\n\t                var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\r\n\t                this.match = this.match.substr(0, this.match.length - 1);\r\n\t                this.matched = this.matched.substr(0, this.matched.length - 1);\r\n\r\n\t                if (lines.length - 1) this.yylineno -= lines.length - 1;\r\n\t                var r = this.yylloc.range;\r\n\r\n\t                this.yylloc = { first_line: this.yylloc.first_line,\r\n\t                    last_line: this.yylineno + 1,\r\n\t                    first_column: this.yylloc.first_column,\r\n\t                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len\r\n\t                };\r\n\r\n\t                if (this.options.ranges) {\r\n\t                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];\r\n\t                }\r\n\t                return this;\r\n\t            },\r\n\t            more: function more() {\r\n\t                this._more = true;\r\n\t                return this;\r\n\t            },\r\n\t            less: function less(n) {\r\n\t                this.unput(this.match.slice(n));\r\n\t            },\r\n\t            pastInput: function pastInput() {\r\n\t                var past = this.matched.substr(0, this.matched.length - this.match.length);\r\n\t                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\\n/g, \"\");\r\n\t            },\r\n\t            upcomingInput: function upcomingInput() {\r\n\t                var next = this.match;\r\n\t                if (next.length < 20) {\r\n\t                    next += this._input.substr(0, 20 - next.length);\r\n\t                }\r\n\t                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\r\n\t            },\r\n\t            showPosition: function showPosition() {\r\n\t                var pre = this.pastInput();\r\n\t                var c = new Array(pre.length + 1).join(\"-\");\r\n\t                return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\r\n\t            },\r\n\t            next: function next() {\r\n\t                if (this.done) {\r\n\t                    return this.EOF;\r\n\t                }\r\n\t                if (!this._input) this.done = true;\r\n\r\n\t                var token, match, tempMatch, index, col, lines;\r\n\t                if (!this._more) {\r\n\t                    this.yytext = '';\r\n\t                    this.match = '';\r\n\t                }\r\n\t                var rules = this._currentRules();\r\n\t                for (var i = 0; i < rules.length; i++) {\r\n\t                    tempMatch = this._input.match(this.rules[rules[i]]);\r\n\t                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\r\n\t                        match = tempMatch;\r\n\t                        index = i;\r\n\t                        if (!this.options.flex) break;\r\n\t                    }\r\n\t                }\r\n\t                if (match) {\r\n\t                    lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\r\n\t                    if (lines) this.yylineno += lines.length;\r\n\t                    this.yylloc = { first_line: this.yylloc.last_line,\r\n\t                        last_line: this.yylineno + 1,\r\n\t                        first_column: this.yylloc.last_column,\r\n\t                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length : this.yylloc.last_column + match[0].length };\r\n\t                    this.yytext += match[0];\r\n\t                    this.match += match[0];\r\n\t                    this.matches = match;\r\n\t                    this.yyleng = this.yytext.length;\r\n\t                    if (this.options.ranges) {\r\n\t                        this.yylloc.range = [this.offset, this.offset += this.yyleng];\r\n\t                    }\r\n\t                    this._more = false;\r\n\t                    this._input = this._input.slice(match[0].length);\r\n\t                    this.matched += match[0];\r\n\t                    token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);\r\n\t                    if (this.done && this._input) this.done = false;\r\n\t                    if (token) return token;else return;\r\n\t                }\r\n\t                if (this._input === \"\") {\r\n\t                    return this.EOF;\r\n\t                } else {\r\n\t                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), { text: \"\", token: null, line: this.yylineno });\r\n\t                }\r\n\t            },\r\n\t            lex: function lex() {\r\n\t                var r = this.next();\r\n\t                if (typeof r !== 'undefined') {\r\n\t                    return r;\r\n\t                } else {\r\n\t                    return this.lex();\r\n\t                }\r\n\t            },\r\n\t            begin: function begin(condition) {\r\n\t                this.conditionStack.push(condition);\r\n\t            },\r\n\t            popState: function popState() {\r\n\t                return this.conditionStack.pop();\r\n\t            },\r\n\t            _currentRules: function _currentRules() {\r\n\t                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\r\n\t            },\r\n\t            topState: function topState() {\r\n\t                return this.conditionStack[this.conditionStack.length - 2];\r\n\t            },\r\n\t            pushState: function begin(condition) {\r\n\t                this.begin(condition);\r\n\t            } };\r\n\t        lexer.options = {};\r\n\t        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\r\n\r\n\t            function strip(start, end) {\r\n\t                return yy_.yytext = yy_.yytext.substring(start, yy_.yyleng - end + start);\r\n\t            }\r\n\r\n\t            var YYSTATE = YY_START;\r\n\t            switch ($avoiding_name_collisions) {\r\n\t                case 0:\r\n\t                    if (yy_.yytext.slice(-2) === \"\\\\\\\\\") {\r\n\t                        strip(0, 1);\r\n\t                        this.begin(\"mu\");\r\n\t                    } else if (yy_.yytext.slice(-1) === \"\\\\\") {\r\n\t                        strip(0, 1);\r\n\t                        this.begin(\"emu\");\r\n\t                    } else {\r\n\t                        this.begin(\"mu\");\r\n\t                    }\r\n\t                    if (yy_.yytext) return 15;\r\n\r\n\t                    break;\r\n\t                case 1:\r\n\t                    return 15;\r\n\t                    break;\r\n\t                case 2:\r\n\t                    this.popState();\r\n\t                    return 15;\r\n\r\n\t                    break;\r\n\t                case 3:\r\n\t                    this.begin('raw');return 15;\r\n\t                    break;\r\n\t                case 4:\r\n\t                    this.popState();\r\n\t                    // Should be using `this.topState()` below, but it currently\r\n\t                    // returns the second top instead of the first top. Opened an\r\n\t                    // issue about it at https://github.com/zaach/jison/issues/291\r\n\t                    if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {\r\n\t                        return 15;\r\n\t                    } else {\r\n\t                        strip(5, 9);\r\n\t                        return 'END_RAW_BLOCK';\r\n\t                    }\r\n\r\n\t                    break;\r\n\t                case 5:\r\n\t                    return 15;\r\n\t                    break;\r\n\t                case 6:\r\n\t                    this.popState();\r\n\t                    return 14;\r\n\r\n\t                    break;\r\n\t                case 7:\r\n\t                    return 65;\r\n\t                    break;\r\n\t                case 8:\r\n\t                    return 68;\r\n\t                    break;\r\n\t                case 9:\r\n\t                    return 19;\r\n\t                    break;\r\n\t                case 10:\r\n\t                    this.popState();\r\n\t                    this.begin('raw');\r\n\t                    return 23;\r\n\r\n\t                    break;\r\n\t                case 11:\r\n\t                    return 55;\r\n\t                    break;\r\n\t                case 12:\r\n\t                    return 60;\r\n\t                    break;\r\n\t                case 13:\r\n\t                    return 29;\r\n\t                    break;\r\n\t                case 14:\r\n\t                    return 47;\r\n\t                    break;\r\n\t                case 15:\r\n\t                    this.popState();return 44;\r\n\t                    break;\r\n\t                case 16:\r\n\t                    this.popState();return 44;\r\n\t                    break;\r\n\t                case 17:\r\n\t                    return 34;\r\n\t                    break;\r\n\t                case 18:\r\n\t                    return 39;\r\n\t                    break;\r\n\t                case 19:\r\n\t                    return 51;\r\n\t                    break;\r\n\t                case 20:\r\n\t                    return 48;\r\n\t                    break;\r\n\t                case 21:\r\n\t                    this.unput(yy_.yytext);\r\n\t                    this.popState();\r\n\t                    this.begin('com');\r\n\r\n\t                    break;\r\n\t                case 22:\r\n\t                    this.popState();\r\n\t                    return 14;\r\n\r\n\t                    break;\r\n\t                case 23:\r\n\t                    return 48;\r\n\t                    break;\r\n\t                case 24:\r\n\t                    return 73;\r\n\t                    break;\r\n\t                case 25:\r\n\t                    return 72;\r\n\t                    break;\r\n\t                case 26:\r\n\t                    return 72;\r\n\t                    break;\r\n\t                case 27:\r\n\t                    return 87;\r\n\t                    break;\r\n\t                case 28:\r\n\t                    // ignore whitespace\r\n\t                    break;\r\n\t                case 29:\r\n\t                    this.popState();return 54;\r\n\t                    break;\r\n\t                case 30:\r\n\t                    this.popState();return 33;\r\n\t                    break;\r\n\t                case 31:\r\n\t                    yy_.yytext = strip(1, 2).replace(/\\\\\"/g, '\"');return 80;\r\n\t                    break;\r\n\t                case 32:\r\n\t                    yy_.yytext = strip(1, 2).replace(/\\\\'/g, \"'\");return 80;\r\n\t                    break;\r\n\t                case 33:\r\n\t                    return 85;\r\n\t                    break;\r\n\t                case 34:\r\n\t                    return 82;\r\n\t                    break;\r\n\t                case 35:\r\n\t                    return 82;\r\n\t                    break;\r\n\t                case 36:\r\n\t                    return 83;\r\n\t                    break;\r\n\t                case 37:\r\n\t                    return 84;\r\n\t                    break;\r\n\t                case 38:\r\n\t                    return 81;\r\n\t                    break;\r\n\t                case 39:\r\n\t                    return 75;\r\n\t                    break;\r\n\t                case 40:\r\n\t                    return 77;\r\n\t                    break;\r\n\t                case 41:\r\n\t                    return 72;\r\n\t                    break;\r\n\t                case 42:\r\n\t                    yy_.yytext = yy_.yytext.replace(/\\\\([\\\\\\]])/g, '$1');return 72;\r\n\t                    break;\r\n\t                case 43:\r\n\t                    return 'INVALID';\r\n\t                    break;\r\n\t                case 44:\r\n\t                    return 5;\r\n\t                    break;\r\n\t            }\r\n\t        };\r\n\t        lexer.rules = [/^(?:[^\\x00]*?(?=(\\{\\{)))/, /^(?:[^\\x00]+)/, /^(?:[^\\x00]{2,}?(?=(\\{\\{|\\\\\\{\\{|\\\\\\\\\\{\\{|$)))/, /^(?:\\{\\{\\{\\{(?=[^\\/]))/, /^(?:\\{\\{\\{\\{\\/[^\\s!\"#%-,\\.\\/;->@\\[-\\^`\\{-~]+(?=[=}\\s\\/.])\\}\\}\\}\\})/, /^(?:[^\\x00]+?(?=(\\{\\{\\{\\{)))/, /^(?:[\\s\\S]*?--(~)?\\}\\})/, /^(?:\\()/, /^(?:\\))/, /^(?:\\{\\{\\{\\{)/, /^(?:\\}\\}\\}\\})/, /^(?:\\{\\{(~)?>)/, /^(?:\\{\\{(~)?#>)/, /^(?:\\{\\{(~)?#\\*?)/, /^(?:\\{\\{(~)?\\/)/, /^(?:\\{\\{(~)?\\^\\s*(~)?\\}\\})/, /^(?:\\{\\{(~)?\\s*else\\s*(~)?\\}\\})/, /^(?:\\{\\{(~)?\\^)/, /^(?:\\{\\{(~)?\\s*else\\b)/, /^(?:\\{\\{(~)?\\{)/, /^(?:\\{\\{(~)?&)/, /^(?:\\{\\{(~)?!--)/, /^(?:\\{\\{(~)?![\\s\\S]*?\\}\\})/, /^(?:\\{\\{(~)?\\*?)/, /^(?:=)/, /^(?:\\.\\.)/, /^(?:\\.(?=([=~}\\s\\/.)|])))/, /^(?:[\\/.])/, /^(?:\\s+)/, /^(?:\\}(~)?\\}\\})/, /^(?:(~)?\\}\\})/, /^(?:\"(\\\\[\"]|[^\"])*\")/, /^(?:'(\\\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\\s)])))/, /^(?:false(?=([~}\\s)])))/, /^(?:undefined(?=([~}\\s)])))/, /^(?:null(?=([~}\\s)])))/, /^(?:-?[0-9]+(?:\\.[0-9]+)?(?=([~}\\s)])))/, /^(?:as\\s+\\|)/, /^(?:\\|)/, /^(?:([^\\s!\"#%-,\\.\\/;->@\\[-\\^`\\{-~]+(?=([=~}\\s\\/.)|]))))/, /^(?:\\[(\\\\\\]|[^\\]])*\\])/, /^(?:.)/, /^(?:$)/];\r\n\t        lexer.conditions = { \"mu\": { \"rules\": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], \"inclusive\": false }, \"emu\": { \"rules\": [2], \"inclusive\": false }, \"com\": { \"rules\": [6], \"inclusive\": false }, \"raw\": { \"rules\": [3, 4, 5], \"inclusive\": false }, \"INITIAL\": { \"rules\": [0, 1, 44], \"inclusive\": true } };\r\n\t        return lexer;\r\n\t    })();\r\n\t    parser.lexer = lexer;\r\n\t    \r\n\t    function Parser() {\r\n\t        this.yy = {};\r\n\t    }\r\n\t    \r\n\t    Parser.prototype = parser;\r\n\t    parser.Parser = Parser;\r\n\t    return new Parser();\r\n\t})();\r\n\r\n\treturn handlebars;\r\n\r\n});\ndefine('skylark-handlebars/compiler/visitor',['../exception'], function (Exception) {\n    'use strict';\n    function Visitor() {\n        this.parents = [];\n    }\n    Visitor.prototype = {\n        constructor: Visitor,\n        mutating: false,\n        acceptKey: function (node, name) {\n            let value = this.accept(node[name]);\n            if (this.mutating) {\n                if (value && !Visitor.prototype[value.type]) {\n                    throw new Exception('Unexpected node type \"' + value.type + '\" found when accepting ' + name + ' on ' + node.type);\n                }\n                node[name] = value;\n            }\n        },\n        acceptRequired: function (node, name) {\n            this.acceptKey(node, name);\n            if (!node[name]) {\n                throw new Exception(node.type + ' requires ' + name);\n            }\n        },\n        acceptArray: function (array) {\n            for (let i = 0, l = array.length; i < l; i++) {\n                this.acceptKey(array, i);\n                if (!array[i]) {\n                    array.splice(i, 1);\n                    i--;\n                    l--;\n                }\n            }\n        },\n        accept: function (object) {\n            if (!object) {\n                return;\n            }\n            if (!this[object.type]) {\n                throw new Exception('Unknown type: ' + object.type, object);\n            }\n            if (this.current) {\n                this.parents.unshift(this.current);\n            }\n            this.current = object;\n            let ret = this[object.type](object);\n            this.current = this.parents.shift();\n            if (!this.mutating || ret) {\n                return ret;\n            } else if (ret !== false) {\n                return object;\n            }\n        },\n        Program: function (program) {\n            this.acceptArray(program.body);\n        },\n        MustacheStatement: visitSubExpression,\n        Decorator: visitSubExpression,\n        BlockStatement: visitBlock,\n        DecoratorBlock: visitBlock,\n        PartialStatement: visitPartial,\n        PartialBlockStatement: function (partial) {\n            visitPartial.call(this, partial);\n            this.acceptKey(partial, 'program');\n        },\n        ContentStatement: function () {\n        },\n        CommentStatement: function () {\n        },\n        SubExpression: visitSubExpression,\n        PathExpression: function () {\n        },\n        StringLiteral: function () {\n        },\n        NumberLiteral: function () {\n        },\n        BooleanLiteral: function () {\n        },\n        UndefinedLiteral: function () {\n        },\n        NullLiteral: function () {\n        },\n        Hash: function (hash) {\n            this.acceptArray(hash.pairs);\n        },\n        HashPair: function (pair) {\n            this.acceptRequired(pair, 'value');\n        }\n    };\n    function visitSubExpression(mustache) {\n        this.acceptRequired(mustache, 'path');\n        this.acceptArray(mustache.params);\n        this.acceptKey(mustache, 'hash');\n    }\n    function visitBlock(block) {\n        visitSubExpression.call(this, block);\n        this.acceptKey(block, 'program');\n        this.acceptKey(block, 'inverse');\n    }\n    function visitPartial(partial) {\n        this.acceptRequired(partial, 'name');\n        this.acceptArray(partial.params);\n        this.acceptKey(partial, 'hash');\n    }\n    return Visitor;\n});\ndefine('skylark-handlebars/compiler/whitespace-control',['./visitor'], function (Visitor) {\n    'use strict';\n    function WhitespaceControl(options = {}) {\n        this.options = options;\n    }\n    WhitespaceControl.prototype = new Visitor();\n    WhitespaceControl.prototype.Program = function (program) {\n        const doStandalone = !this.options.ignoreStandalone;\n        let isRoot = !this.isRootSeen;\n        this.isRootSeen = true;\n        let body = program.body;\n        for (let i = 0, l = body.length; i < l; i++) {\n            let current = body[i], strip = this.accept(current);\n            if (!strip) {\n                continue;\n            }\n            let _isPrevWhitespace = isPrevWhitespace(body, i, isRoot), _isNextWhitespace = isNextWhitespace(body, i, isRoot), openStandalone = strip.openStandalone && _isPrevWhitespace, closeStandalone = strip.closeStandalone && _isNextWhitespace, inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;\n            if (strip.close) {\n                omitRight(body, i, true);\n            }\n            if (strip.open) {\n                omitLeft(body, i, true);\n            }\n            if (doStandalone && inlineStandalone) {\n                omitRight(body, i);\n                if (omitLeft(body, i)) {\n                    if (current.type === 'PartialStatement') {\n                        current.indent = /([ \\t]+$)/.exec(body[i - 1].original)[1];\n                    }\n                }\n            }\n            if (doStandalone && openStandalone) {\n                omitRight((current.program || current.inverse).body);\n                omitLeft(body, i);\n            }\n            if (doStandalone && closeStandalone) {\n                omitRight(body, i);\n                omitLeft((current.inverse || current.program).body);\n            }\n        }\n        return program;\n    };\n    WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {\n        this.accept(block.program);\n        this.accept(block.inverse);\n        let program = block.program || block.inverse, inverse = block.program && block.inverse, firstInverse = inverse, lastInverse = inverse;\n        if (inverse && inverse.chained) {\n            firstInverse = inverse.body[0].program;\n            while (lastInverse.chained) {\n                lastInverse = lastInverse.body[lastInverse.body.length - 1].program;\n            }\n        }\n        let strip = {\n            open: block.openStrip.open,\n            close: block.closeStrip.close,\n            openStandalone: isNextWhitespace(program.body),\n            closeStandalone: isPrevWhitespace((firstInverse || program).body)\n        };\n        if (block.openStrip.close) {\n            omitRight(program.body, null, true);\n        }\n        if (inverse) {\n            let inverseStrip = block.inverseStrip;\n            if (inverseStrip.open) {\n                omitLeft(program.body, null, true);\n            }\n            if (inverseStrip.close) {\n                omitRight(firstInverse.body, null, true);\n            }\n            if (block.closeStrip.open) {\n                omitLeft(lastInverse.body, null, true);\n            }\n            if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {\n                omitLeft(program.body);\n                omitRight(firstInverse.body);\n            }\n        } else if (block.closeStrip.open) {\n            omitLeft(program.body, null, true);\n        }\n        return strip;\n    };\n    WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {\n        return mustache.strip;\n    };\n    WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {\n        let strip = node.strip || {};\n        return {\n            inlineStandalone: true,\n            open: strip.open,\n            close: strip.close\n        };\n    };\n    function isPrevWhitespace(body, i, isRoot) {\n        if (i === undefined) {\n            i = body.length;\n        }\n        let prev = body[i - 1], sibling = body[i - 2];\n        if (!prev) {\n            return isRoot;\n        }\n        if (prev.type === 'ContentStatement') {\n            return (sibling || !isRoot ? /\\r?\\n\\s*?$/ : /(^|\\r?\\n)\\s*?$/).test(prev.original);\n        }\n    }\n    function isNextWhitespace(body, i, isRoot) {\n        if (i === undefined) {\n            i = -1;\n        }\n        let next = body[i + 1], sibling = body[i + 2];\n        if (!next) {\n            return isRoot;\n        }\n        if (next.type === 'ContentStatement') {\n            return (sibling || !isRoot ? /^\\s*?\\r?\\n/ : /^\\s*?(\\r?\\n|$)/).test(next.original);\n        }\n    }\n    function omitRight(body, i, multiple) {\n        let current = body[i == null ? 0 : i + 1];\n        if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {\n            return;\n        }\n        let original = current.value;\n        current.value = current.value.replace(multiple ? /^\\s+/ : /^[ \\t]*\\r?\\n?/, '');\n        current.rightStripped = current.value !== original;\n    }\n    function omitLeft(body, i, multiple) {\n        let current = body[i == null ? body.length - 1 : i - 1];\n        if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {\n            return;\n        }\n        let original = current.value;\n        current.value = current.value.replace(multiple ? /\\s+$/ : /[ \\t]+$/, '');\n        current.leftStripped = current.value !== original;\n        return current.leftStripped;\n    }\n    return WhitespaceControl;\n});\ndefine('skylark-handlebars/compiler/helpers',['../exception'], function (Exception) {\n    'use strict';\n    function validateClose(open, close) {\n        close = close.path ? close.path.original : close;\n        if (open.path.original !== close) {\n            let errorNode = { loc: open.path.loc };\n            throw new Exception(open.path.original + \" doesn't match \" + close, errorNode);\n        }\n    }\n    function SourceLocation(source, locInfo) {\n        this.source = source;\n        this.start = {\n            line: locInfo.first_line,\n            column: locInfo.first_column\n        };\n        this.end = {\n            line: locInfo.last_line,\n            column: locInfo.last_column\n        };\n    }\n    function id(token) {\n        if (/^\\[.*\\]$/.test(token)) {\n            return token.substring(1, token.length - 1);\n        } else {\n            return token;\n        }\n    }\n    function stripFlags(open, close) {\n        return {\n            open: open.charAt(2) === '~',\n            close: close.charAt(close.length - 3) === '~'\n        };\n    }\n    function stripComment(comment) {\n        return comment.replace(/^\\{\\{~?!-?-?/, '').replace(/-?-?~?\\}\\}$/, '');\n    }\n    function preparePath(data, parts, loc) {\n        loc = this.locInfo(loc);\n        let original = data ? '@' : '', dig = [], depth = 0;\n        for (let i = 0, l = parts.length; i < l; i++) {\n            let part = parts[i].part, isLiteral = parts[i].original !== part;\n            original += (parts[i].separator || '') + part;\n            if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {\n                if (dig.length > 0) {\n                    throw new Exception('Invalid path: ' + original, { loc });\n                } else if (part === '..') {\n                    depth++;\n                }\n            } else {\n                dig.push(part);\n            }\n        }\n        return {\n            type: 'PathExpression',\n            data,\n            depth,\n            parts: dig,\n            original,\n            loc\n        };\n    }\n    function prepareMustache(path, params, hash, open, strip, locInfo) {\n        let escapeFlag = open.charAt(3) || open.charAt(2), escaped = escapeFlag !== '{' && escapeFlag !== '&';\n        let decorator = /\\*/.test(open);\n        return {\n            type: decorator ? 'Decorator' : 'MustacheStatement',\n            path,\n            params,\n            hash,\n            escaped,\n            strip,\n            loc: this.locInfo(locInfo)\n        };\n    }\n    function prepareRawBlock(openRawBlock, contents, close, locInfo) {\n        validateClose(openRawBlock, close);\n        locInfo = this.locInfo(locInfo);\n        let program = {\n            type: 'Program',\n            body: contents,\n            strip: {},\n            loc: locInfo\n        };\n        return {\n            type: 'BlockStatement',\n            path: openRawBlock.path,\n            params: openRawBlock.params,\n            hash: openRawBlock.hash,\n            program,\n            openStrip: {},\n            inverseStrip: {},\n            closeStrip: {},\n            loc: locInfo\n        };\n    }\n    function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {\n        if (close && close.path) {\n            validateClose(openBlock, close);\n        }\n        let decorator = /\\*/.test(openBlock.open);\n        program.blockParams = openBlock.blockParams;\n        let inverse, inverseStrip;\n        if (inverseAndProgram) {\n            if (decorator) {\n                throw new Exception('Unexpected inverse block on decorator', inverseAndProgram);\n            }\n            if (inverseAndProgram.chain) {\n                inverseAndProgram.program.body[0].closeStrip = close.strip;\n            }\n            inverseStrip = inverseAndProgram.strip;\n            inverse = inverseAndProgram.program;\n        }\n        if (inverted) {\n            inverted = inverse;\n            inverse = program;\n            program = inverted;\n        }\n        return {\n            type: decorator ? 'DecoratorBlock' : 'BlockStatement',\n            path: openBlock.path,\n            params: openBlock.params,\n            hash: openBlock.hash,\n            program,\n            inverse,\n            openStrip: openBlock.strip,\n            inverseStrip,\n            closeStrip: close && close.strip,\n            loc: this.locInfo(locInfo)\n        };\n    }\n    function prepareProgram(statements, loc) {\n        if (!loc && statements.length) {\n            const firstLoc = statements[0].loc, lastLoc = statements[statements.length - 1].loc;\n            if (firstLoc && lastLoc) {\n                loc = {\n                    source: firstLoc.source,\n                    start: {\n                        line: firstLoc.start.line,\n                        column: firstLoc.start.column\n                    },\n                    end: {\n                        line: lastLoc.end.line,\n                        column: lastLoc.end.column\n                    }\n                };\n            }\n        }\n        return {\n            type: 'Program',\n            body: statements,\n            strip: {},\n            loc: loc\n        };\n    }\n    function preparePartialBlock(open, program, close, locInfo) {\n        validateClose(open, close);\n        return {\n            type: 'PartialBlockStatement',\n            name: open.path,\n            params: open.params,\n            hash: open.hash,\n            program,\n            openStrip: open.strip,\n            closeStrip: close && close.strip,\n            loc: this.locInfo(locInfo)\n        };\n    }\n    return {\n        SourceLocation: SourceLocation,\n        id: id,\n        stripFlags: stripFlags,\n        stripComment: stripComment,\n        preparePath: preparePath,\n        prepareMustache: prepareMustache,\n        prepareRawBlock: prepareRawBlock,\n        prepareBlock: prepareBlock,\n        prepareProgram: prepareProgram,\n        preparePartialBlock: preparePartialBlock\n    };\n});\ndefine('skylark-handlebars/compiler/base',[\n    './parser',\n    './whitespace-control',\n    './helpers',\n    '../utils'\n], function (parser, WhitespaceControl, Helpers, a) {\n    'use strict';\n    let yy = {};\n    a.extend(yy, Helpers);\n    function parseWithoutProcessing(input, options) {\n        if (input.type === 'Program') {\n            return input;\n        }\n        parser.yy = yy;\n        yy.locInfo = function (locInfo) {\n            return new yy.SourceLocation(options && options.srcName, locInfo);\n        };\n        let ast = parser.parse(input);\n        return ast;\n    }\n    function parse(input, options) {\n        let ast = parseWithoutProcessing(input, options);\n        let strip = new WhitespaceControl(options);\n        return strip.accept(ast);\n    }\n    return {\n        parser,\n        parseWithoutProcessing: parseWithoutProcessing,\n        parse: parse\n    };\n});\ndefine('skylark-handlebars/compiler/compiler',[\n    '../exception',\n    '../utils',\n    './ast'\n], function (Exception, utils, AST) {\n    'use strict';\n    const slice = [].slice;\n    function Compiler() {\n    }\n    Compiler.prototype = {\n        compiler: Compiler,\n        equals: function (other) {\n            let len = this.opcodes.length;\n            if (other.opcodes.length !== len) {\n                return false;\n            }\n            for (let i = 0; i < len; i++) {\n                let opcode = this.opcodes[i], otherOpcode = other.opcodes[i];\n                if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {\n                    return false;\n                }\n            }\n            len = this.children.length;\n            for (let i = 0; i < len; i++) {\n                if (!this.children[i].equals(other.children[i])) {\n                    return false;\n                }\n            }\n            return true;\n        },\n        guid: 0,\n        compile: function (program, options) {\n            this.sourceNode = [];\n            this.opcodes = [];\n            this.children = [];\n            this.options = options;\n            this.stringParams = options.stringParams;\n            this.trackIds = options.trackIds;\n            options.blockParams = options.blockParams || [];\n            options.knownHelpers = utils.extend(Object.create(null), {\n                helperMissing: true,\n                blockHelperMissing: true,\n                each: true,\n                if: true,\n                unless: true,\n                with: true,\n                log: true,\n                lookup: true\n            }, options.knownHelpers);\n            return this.accept(program);\n        },\n        compileProgram: function (program) {\n            let childCompiler = new this.compiler(), result = childCompiler.compile(program, this.options), guid = this.guid++;\n            this.usePartial = this.usePartial || result.usePartial;\n            this.children[guid] = result;\n            this.useDepths = this.useDepths || result.useDepths;\n            return guid;\n        },\n        accept: function (node) {\n            if (!this[node.type]) {\n                throw new Exception('Unknown type: ' + node.type, node);\n            }\n            this.sourceNode.unshift(node);\n            let ret = this[node.type](node);\n            this.sourceNode.shift();\n            return ret;\n        },\n        Program: function (program) {\n            this.options.blockParams.unshift(program.blockParams);\n            let body = program.body, bodyLength = body.length;\n            for (let i = 0; i < bodyLength; i++) {\n                this.accept(body[i]);\n            }\n            this.options.blockParams.shift();\n            this.isSimple = bodyLength === 1;\n            this.blockParams = program.blockParams ? program.blockParams.length : 0;\n            return this;\n        },\n        BlockStatement: function (block) {\n            transformLiteralToPath(block);\n            let program = block.program, inverse = block.inverse;\n            program = program && this.compileProgram(program);\n            inverse = inverse && this.compileProgram(inverse);\n            let type = this.classifySexpr(block);\n            if (type === 'helper') {\n                this.helperSexpr(block, program, inverse);\n            } else if (type === 'simple') {\n                this.simpleSexpr(block);\n                this.opcode('pushProgram', program);\n                this.opcode('pushProgram', inverse);\n                this.opcode('emptyHash');\n                this.opcode('blockValue', block.path.original);\n            } else {\n                this.ambiguousSexpr(block, program, inverse);\n                this.opcode('pushProgram', program);\n                this.opcode('pushProgram', inverse);\n                this.opcode('emptyHash');\n                this.opcode('ambiguousBlockValue');\n            }\n            this.opcode('append');\n        },\n        DecoratorBlock(decorator) {\n            let program = decorator.program && this.compileProgram(decorator.program);\n            let params = this.setupFullMustacheParams(decorator, program, undefined), path = decorator.path;\n            this.useDecorators = true;\n            this.opcode('registerDecorator', params.length, path.original);\n        },\n        PartialStatement: function (partial) {\n            this.usePartial = true;\n            let program = partial.program;\n            if (program) {\n                program = this.compileProgram(partial.program);\n            }\n            let params = partial.params;\n            if (params.length > 1) {\n                throw new Exception('Unsupported number of partial arguments: ' + params.length, partial);\n            } else if (!params.length) {\n                if (this.options.explicitPartialContext) {\n                    this.opcode('pushLiteral', 'undefined');\n                } else {\n                    params.push({\n                        type: 'PathExpression',\n                        parts: [],\n                        depth: 0\n                    });\n                }\n            }\n            let partialName = partial.name.original, isDynamic = partial.name.type === 'SubExpression';\n            if (isDynamic) {\n                this.accept(partial.name);\n            }\n            this.setupFullMustacheParams(partial, program, undefined, true);\n            let indent = partial.indent || '';\n            if (this.options.preventIndent && indent) {\n                this.opcode('appendContent', indent);\n                indent = '';\n            }\n            this.opcode('invokePartial', isDynamic, partialName, indent);\n            this.opcode('append');\n        },\n        PartialBlockStatement: function (partialBlock) {\n            this.PartialStatement(partialBlock);\n        },\n        MustacheStatement: function (mustache) {\n            this.SubExpression(mustache);\n            if (mustache.escaped && !this.options.noEscape) {\n                this.opcode('appendEscaped');\n            } else {\n                this.opcode('append');\n            }\n        },\n        Decorator(decorator) {\n            this.DecoratorBlock(decorator);\n        },\n        ContentStatement: function (content) {\n            if (content.value) {\n                this.opcode('appendContent', content.value);\n            }\n        },\n        CommentStatement: function () {\n        },\n        SubExpression: function (sexpr) {\n            transformLiteralToPath(sexpr);\n            let type = this.classifySexpr(sexpr);\n            if (type === 'simple') {\n                this.simpleSexpr(sexpr);\n            } else if (type === 'helper') {\n                this.helperSexpr(sexpr);\n            } else {\n                this.ambiguousSexpr(sexpr);\n            }\n        },\n        ambiguousSexpr: function (sexpr, program, inverse) {\n            let path = sexpr.path, name = path.parts[0], isBlock = program != null || inverse != null;\n            this.opcode('getContext', path.depth);\n            this.opcode('pushProgram', program);\n            this.opcode('pushProgram', inverse);\n            path.strict = true;\n            this.accept(path);\n            this.opcode('invokeAmbiguous', name, isBlock);\n        },\n        simpleSexpr: function (sexpr) {\n            let path = sexpr.path;\n            path.strict = true;\n            this.accept(path);\n            this.opcode('resolvePossibleLambda');\n        },\n        helperSexpr: function (sexpr, program, inverse) {\n            let params = this.setupFullMustacheParams(sexpr, program, inverse), path = sexpr.path, name = path.parts[0];\n            if (this.options.knownHelpers[name]) {\n                this.opcode('invokeKnownHelper', params.length, name);\n            } else if (this.options.knownHelpersOnly) {\n                throw new Exception('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);\n            } else {\n                path.strict = true;\n                path.falsy = true;\n                this.accept(path);\n                this.opcode('invokeHelper', params.length, path.original, AST.helpers.simpleId(path));\n            }\n        },\n        PathExpression: function (path) {\n            this.addDepth(path.depth);\n            this.opcode('getContext', path.depth);\n            let name = path.parts[0], scoped = AST.helpers.scopedId(path), blockParamId = !path.depth && !scoped && this.blockParamIndex(name);\n            if (blockParamId) {\n                this.opcode('lookupBlockParam', blockParamId, path.parts);\n            } else if (!name) {\n                this.opcode('pushContext');\n            } else if (path.data) {\n                this.options.data = true;\n                this.opcode('lookupData', path.depth, path.parts, path.strict);\n            } else {\n                this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);\n            }\n        },\n        StringLiteral: function (string) {\n            this.opcode('pushString', string.value);\n        },\n        NumberLiteral: function (number) {\n            this.opcode('pushLiteral', number.value);\n        },\n        BooleanLiteral: function (bool) {\n            this.opcode('pushLiteral', bool.value);\n        },\n        UndefinedLiteral: function () {\n            this.opcode('pushLiteral', 'undefined');\n        },\n        NullLiteral: function () {\n            this.opcode('pushLiteral', 'null');\n        },\n        Hash: function (hash) {\n            let pairs = hash.pairs, i = 0, l = pairs.length;\n            this.opcode('pushHash');\n            for (; i < l; i++) {\n                this.pushParam(pairs[i].value);\n            }\n            while (i--) {\n                this.opcode('assignToHash', pairs[i].key);\n            }\n            this.opcode('popHash');\n        },\n        opcode: function (name) {\n            this.opcodes.push({\n                opcode: name,\n                args: slice.call(arguments, 1),\n                loc: this.sourceNode[0].loc\n            });\n        },\n        addDepth: function (depth) {\n            if (!depth) {\n                return;\n            }\n            this.useDepths = true;\n        },\n        classifySexpr: function (sexpr) {\n            let isSimple = AST.helpers.simpleId(sexpr.path);\n            let isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);\n            let isHelper = !isBlockParam && AST.helpers.helperExpression(sexpr);\n            let isEligible = !isBlockParam && (isHelper || isSimple);\n            if (isEligible && !isHelper) {\n                let name = sexpr.path.parts[0], options = this.options;\n                if (options.knownHelpers[name]) {\n                    isHelper = true;\n                } else if (options.knownHelpersOnly) {\n                    isEligible = false;\n                }\n            }\n            if (isHelper) {\n                return 'helper';\n            } else if (isEligible) {\n                return 'ambiguous';\n            } else {\n                return 'simple';\n            }\n        },\n        pushParams: function (params) {\n            for (let i = 0, l = params.length; i < l; i++) {\n                this.pushParam(params[i]);\n            }\n        },\n        pushParam: function (val) {\n            let value = val.value != null ? val.value : val.original || '';\n            if (this.stringParams) {\n                if (value.replace) {\n                    value = value.replace(/^(\\.?\\.\\/)*/g, '').replace(/\\//g, '.');\n                }\n                if (val.depth) {\n                    this.addDepth(val.depth);\n                }\n                this.opcode('getContext', val.depth || 0);\n                this.opcode('pushStringParam', value, val.type);\n                if (val.type === 'SubExpression') {\n                    this.accept(val);\n                }\n            } else {\n                if (this.trackIds) {\n                    let blockParamIndex;\n                    if (val.parts && !AST.helpers.scopedId(val) && !val.depth) {\n                        blockParamIndex = this.blockParamIndex(val.parts[0]);\n                    }\n                    if (blockParamIndex) {\n                        let blockParamChild = val.parts.slice(1).join('.');\n                        this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);\n                    } else {\n                        value = val.original || value;\n                        if (value.replace) {\n                            value = value.replace(/^this(?:\\.|$)/, '').replace(/^\\.\\//, '').replace(/^\\.$/, '');\n                        }\n                        this.opcode('pushId', val.type, value);\n                    }\n                }\n                this.accept(val);\n            }\n        },\n        setupFullMustacheParams: function (sexpr, program, inverse, omitEmpty) {\n            let params = sexpr.params;\n            this.pushParams(params);\n            this.opcode('pushProgram', program);\n            this.opcode('pushProgram', inverse);\n            if (sexpr.hash) {\n                this.accept(sexpr.hash);\n            } else {\n                this.opcode('emptyHash', omitEmpty);\n            }\n            return params;\n        },\n        blockParamIndex: function (name) {\n            for (let depth = 0, len = this.options.blockParams.length; depth < len; depth++) {\n                let blockParams = this.options.blockParams[depth], param = blockParams && utils.indexOf(blockParams, name);\n                if (blockParams && param >= 0) {\n                    return [\n                        depth,\n                        param\n                    ];\n                }\n            }\n        }\n    };\n    function precompile(input, options, env) {\n        if (input == null || typeof input !== 'string' && input.type !== 'Program') {\n            throw new Exception('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);\n        }\n        options = options || {};\n        if (!('data' in options)) {\n            options.data = true;\n        }\n        if (options.compat) {\n            options.useDepths = true;\n        }\n        let ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options);\n        return new env.JavaScriptCompiler().compile(environment, options);\n    }\n    function compile(input, options = {}, env) {\n        if (input == null || typeof input !== 'string' && input.type !== 'Program') {\n            throw new Exception('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);\n        }\n        options = utils.extend({}, options);\n        if (!('data' in options)) {\n            options.data = true;\n        }\n        if (options.compat) {\n            options.useDepths = true;\n        }\n        let compiled;\n        function compileInput() {\n            let ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options), templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);\n            return env.template(templateSpec);\n        }\n        function ret(context, execOptions) {\n            if (!compiled) {\n                compiled = compileInput();\n            }\n            return compiled.call(this, context, execOptions);\n        }\n        ret._setup = function (setupOptions) {\n            if (!compiled) {\n                compiled = compileInput();\n            }\n            return compiled._setup(setupOptions);\n        };\n        ret._child = function (i, data, blockParams, depths) {\n            if (!compiled) {\n                compiled = compileInput();\n            }\n            return compiled._child(i, data, blockParams, depths);\n        };\n        return ret;\n    }\n    function argEquals(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (utils.isArray(a) && utils.isArray(b) && a.length === b.length) {\n            for (let i = 0; i < a.length; i++) {\n                if (!argEquals(a[i], b[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    function transformLiteralToPath(sexpr) {\n        if (!sexpr.path.parts) {\n            let literal = sexpr.path;\n            sexpr.path = {\n                type: 'PathExpression',\n                data: false,\n                depth: 0,\n                parts: [literal.original + ''],\n                original: literal.original + '',\n                loc: literal.loc\n            };\n        }\n    }\n    return {\n        Compiler: Compiler,\n        precompile: precompile,\n        compile: compile\n    };\n});\ndefine('skylark-handlebars/compiler/code-gen',['../utils'], function (a) {\n    'use strict';\n    let SourceNode;\n    try {\n        if (typeof define !== 'function' || !define.amd) {\n            let SourceMap = require('source-map');\n            SourceNode = SourceMap.SourceNode;\n        }\n    } catch (err) {\n    }\n    if (!SourceNode) {\n        SourceNode = function (line, column, srcFile, chunks) {\n            this.src = '';\n            if (chunks) {\n                this.add(chunks);\n            }\n        };\n        SourceNode.prototype = {\n            add: function (chunks) {\n                if (a.isArray(chunks)) {\n                    chunks = chunks.join('');\n                }\n                this.src += chunks;\n            },\n            prepend: function (chunks) {\n                if (a.isArray(chunks)) {\n                    chunks = chunks.join('');\n                }\n                this.src = chunks + this.src;\n            },\n            toStringWithSourceMap: function () {\n                return { code: this.toString() };\n            },\n            toString: function () {\n                return this.src;\n            }\n        };\n    }\n    function castChunk(chunk, codeGen, loc) {\n        if (a.isArray(chunk)) {\n            let ret = [];\n            for (let i = 0, len = chunk.length; i < len; i++) {\n                ret.push(codeGen.wrap(chunk[i], loc));\n            }\n            return ret;\n        } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {\n            return chunk + '';\n        }\n        return chunk;\n    }\n    function CodeGen(srcFile) {\n        this.srcFile = srcFile;\n        this.source = [];\n    }\n    CodeGen.prototype = {\n        isEmpty() {\n            return !this.source.length;\n        },\n        prepend: function (source, loc) {\n            this.source.unshift(this.wrap(source, loc));\n        },\n        push: function (source, loc) {\n            this.source.push(this.wrap(source, loc));\n        },\n        merge: function () {\n            let source = this.empty();\n            this.each(function (line) {\n                source.add([\n                    '  ',\n                    line,\n                    '\\n'\n                ]);\n            });\n            return source;\n        },\n        each: function (iter) {\n            for (let i = 0, len = this.source.length; i < len; i++) {\n                iter(this.source[i]);\n            }\n        },\n        empty: function () {\n            let loc = this.currentLocation || { start: {} };\n            return new SourceNode(loc.start.line, loc.start.column, this.srcFile);\n        },\n        wrap: function (chunk, loc = this.currentLocation || { start: {} }) {\n            if (chunk instanceof SourceNode) {\n                return chunk;\n            }\n            chunk = castChunk(chunk, this, loc);\n            return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);\n        },\n        functionCall: function (fn, type, params) {\n            params = this.generateList(params);\n            return this.wrap([\n                fn,\n                type ? '.' + type + '(' : '(',\n                params,\n                ')'\n            ]);\n        },\n        quotedString: function (str) {\n            return '\"' + (str + '').replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029') + '\"';\n        },\n        objectLiteral: function (obj) {\n            let pairs = [];\n            Object.keys(obj).forEach(key => {\n                let value = castChunk(obj[key], this);\n                if (value !== 'undefined') {\n                    pairs.push([\n                        this.quotedString(key),\n                        ':',\n                        value\n                    ]);\n                }\n            });\n            let ret = this.generateList(pairs);\n            ret.prepend('{');\n            ret.add('}');\n            return ret;\n        },\n        generateList: function (entries) {\n            let ret = this.empty();\n            for (let i = 0, len = entries.length; i < len; i++) {\n                if (i) {\n                    ret.add(',');\n                }\n                ret.add(castChunk(entries[i], this));\n            }\n            return ret;\n        },\n        generateArray: function (entries) {\n            let ret = this.generateList(entries);\n            ret.prepend('[');\n            ret.add(']');\n            return ret;\n        }\n    };\n    return CodeGen;\n});\ndefine('skylark-handlebars/compiler/javascript-compiler',[\n    '../base',\n    '../exception',\n    '../utils',\n    './code-gen'\n], function (base, Exception, utils, CodeGen) {\n    'use strict';\n    function Literal(value) {\n        this.value = value;\n    }\n    function JavaScriptCompiler() {\n    }\n    JavaScriptCompiler.prototype = {\n        nameLookup: function (parent, name) {\n            return this.internalNameLookup(parent, name);\n        },\n        depthedLookup: function (name) {\n            return [\n                this.aliasable('container.lookup'),\n                '(depths, \"',\n                name,\n                '\")'\n            ];\n        },\n        compilerInfo: function () {\n            const revision = base.COMPILER_REVISION, versions = base.REVISION_CHANGES[revision];\n            return [\n                revision,\n                versions\n            ];\n        },\n        appendToBuffer: function (source, location, explicit) {\n            if (!utils.isArray(source)) {\n                source = [source];\n            }\n            source = this.source.wrap(source, location);\n            if (this.environment.isSimple) {\n                return [\n                    'return ',\n                    source,\n                    ';'\n                ];\n            } else if (explicit) {\n                return [\n                    'buffer += ',\n                    source,\n                    ';'\n                ];\n            } else {\n                source.appendToBuffer = true;\n                return source;\n            }\n        },\n        initializeBuffer: function () {\n            return this.quotedString('');\n        },\n        internalNameLookup: function (parent, name) {\n            this.lookupPropertyFunctionIsUsed = true;\n            return [\n                'lookupProperty(',\n                parent,\n                ',',\n                JSON.stringify(name),\n                ')'\n            ];\n        },\n        lookupPropertyFunctionIsUsed: false,\n        compile: function (environment, options, context, asObject) {\n            this.environment = environment;\n            this.options = options;\n            this.stringParams = this.options.stringParams;\n            this.trackIds = this.options.trackIds;\n            this.precompile = !asObject;\n            this.name = this.environment.name;\n            this.isChild = !!context;\n            this.context = context || {\n                decorators: [],\n                programs: [],\n                environments: []\n            };\n            this.preamble();\n            this.stackSlot = 0;\n            this.stackVars = [];\n            this.aliases = {};\n            this.registers = { list: [] };\n            this.hashes = [];\n            this.compileStack = [];\n            this.inlineStack = [];\n            this.blockParams = [];\n            this.compileChildren(environment, options);\n            this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;\n            this.useBlockParams = this.useBlockParams || environment.useBlockParams;\n            let opcodes = environment.opcodes, opcode, firstLoc, i, l;\n            for (i = 0, l = opcodes.length; i < l; i++) {\n                opcode = opcodes[i];\n                this.source.currentLocation = opcode.loc;\n                firstLoc = firstLoc || opcode.loc;\n                this[opcode.opcode].apply(this, opcode.args);\n            }\n            this.source.currentLocation = firstLoc;\n            this.pushSource('');\n            if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {\n                throw new Exception('Compile completed with content left on stack');\n            }\n            if (!this.decorators.isEmpty()) {\n                this.useDecorators = true;\n                this.decorators.prepend([\n                    'var decorators = container.decorators, ',\n                    this.lookupPropertyFunctionVarDeclaration(),\n                    ';\\n'\n                ]);\n                this.decorators.push('return fn;');\n                if (asObject) {\n                    this.decorators = Function.apply(this, [\n                        'fn',\n                        'props',\n                        'container',\n                        'depth0',\n                        'data',\n                        'blockParams',\n                        'depths',\n                        this.decorators.merge()\n                    ]);\n                } else {\n                    this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\\n');\n                    this.decorators.push('}\\n');\n                    this.decorators = this.decorators.merge();\n                }\n            } else {\n                this.decorators = undefined;\n            }\n            let fn = this.createFunctionContext(asObject);\n            if (!this.isChild) {\n                let ret = {\n                    compiler: this.compilerInfo(),\n                    main: fn\n                };\n                if (this.decorators) {\n                    ret.main_d = this.decorators;\n                    ret.useDecorators = true;\n                }\n                let {programs, decorators} = this.context;\n                for (i = 0, l = programs.length; i < l; i++) {\n                    if (programs[i]) {\n                        ret[i] = programs[i];\n                        if (decorators[i]) {\n                            ret[i + '_d'] = decorators[i];\n                            ret.useDecorators = true;\n                        }\n                    }\n                }\n                if (this.environment.usePartial) {\n                    ret.usePartial = true;\n                }\n                if (this.options.data) {\n                    ret.useData = true;\n                }\n                if (this.useDepths) {\n                    ret.useDepths = true;\n                }\n                if (this.useBlockParams) {\n                    ret.useBlockParams = true;\n                }\n                if (this.options.compat) {\n                    ret.compat = true;\n                }\n                if (!asObject) {\n                    ret.compiler = JSON.stringify(ret.compiler);\n                    this.source.currentLocation = {\n                        start: {\n                            line: 1,\n                            column: 0\n                        }\n                    };\n                    ret = this.objectLiteral(ret);\n                    if (options.srcName) {\n                        ret = ret.toStringWithSourceMap({ file: options.destName });\n                        ret.map = ret.map && ret.map.toString();\n                    } else {\n                        ret = ret.toString();\n                    }\n                } else {\n                    ret.compilerOptions = this.options;\n                }\n                return ret;\n            } else {\n                return fn;\n            }\n        },\n        preamble: function () {\n            this.lastContext = 0;\n            this.source = new CodeGen(this.options.srcName);\n            this.decorators = new CodeGen(this.options.srcName);\n        },\n        createFunctionContext: function (asObject) {\n            let varDeclarations = '';\n            let locals = this.stackVars.concat(this.registers.list);\n            if (locals.length > 0) {\n                varDeclarations += ', ' + locals.join(', ');\n            }\n            let aliasCount = 0;\n            Object.keys(this.aliases).forEach(alias => {\n                let node = this.aliases[alias];\n                if (node.children && node.referenceCount > 1) {\n                    varDeclarations += ', alias' + ++aliasCount + '=' + alias;\n                    node.children[0] = 'alias' + aliasCount;\n                }\n            });\n            if (this.lookupPropertyFunctionIsUsed) {\n                varDeclarations += ', ' + this.lookupPropertyFunctionVarDeclaration();\n            }\n            let params = [\n                'container',\n                'depth0',\n                'helpers',\n                'partials',\n                'data'\n            ];\n            if (this.useBlockParams || this.useDepths) {\n                params.push('blockParams');\n            }\n            if (this.useDepths) {\n                params.push('depths');\n            }\n            let source = this.mergeSource(varDeclarations);\n            if (asObject) {\n                params.push(source);\n                return Function.apply(this, params);\n            } else {\n                return this.source.wrap([\n                    'function(',\n                    params.join(','),\n                    ') {\\n  ',\n                    source,\n                    '}'\n                ]);\n            }\n        },\n        mergeSource: function (varDeclarations) {\n            let isSimple = this.environment.isSimple, appendOnly = !this.forceBuffer, appendFirst, sourceSeen, bufferStart, bufferEnd;\n            this.source.each(line => {\n                if (line.appendToBuffer) {\n                    if (bufferStart) {\n                        line.prepend('  + ');\n                    } else {\n                        bufferStart = line;\n                    }\n                    bufferEnd = line;\n                } else {\n                    if (bufferStart) {\n                        if (!sourceSeen) {\n                            appendFirst = true;\n                        } else {\n                            bufferStart.prepend('buffer += ');\n                        }\n                        bufferEnd.add(';');\n                        bufferStart = bufferEnd = undefined;\n                    }\n                    sourceSeen = true;\n                    if (!isSimple) {\n                        appendOnly = false;\n                    }\n                }\n            });\n            if (appendOnly) {\n                if (bufferStart) {\n                    bufferStart.prepend('return ');\n                    bufferEnd.add(';');\n                } else if (!sourceSeen) {\n                    this.source.push('return \"\";');\n                }\n            } else {\n                varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());\n                if (bufferStart) {\n                    bufferStart.prepend('return buffer + ');\n                    bufferEnd.add(';');\n                } else {\n                    this.source.push('return buffer;');\n                }\n            }\n            if (varDeclarations) {\n                this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\\n'));\n            }\n            return this.source.merge();\n        },\n        lookupPropertyFunctionVarDeclaration: function () {\n            return `\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    `.trim();\n        },\n        blockValue: function (name) {\n            let blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'), params = [this.contextName(0)];\n            this.setupHelperArgs(name, 0, params);\n            let blockName = this.popStack();\n            params.splice(1, 0, blockName);\n            this.push(this.source.functionCall(blockHelperMissing, 'call', params));\n        },\n        ambiguousBlockValue: function () {\n            let blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'), params = [this.contextName(0)];\n            this.setupHelperArgs('', 0, params, true);\n            this.flushInline();\n            let current = this.topStack();\n            params.splice(1, 0, current);\n            this.pushSource([\n                'if (!',\n                this.lastHelper,\n                ') { ',\n                current,\n                ' = ',\n                this.source.functionCall(blockHelperMissing, 'call', params),\n                '}'\n            ]);\n        },\n        appendContent: function (content) {\n            if (this.pendingContent) {\n                content = this.pendingContent + content;\n            } else {\n                this.pendingLocation = this.source.currentLocation;\n            }\n            this.pendingContent = content;\n        },\n        append: function () {\n            if (this.isInline()) {\n                this.replaceStack(current => [\n                    ' != null ? ',\n                    current,\n                    ' : \"\"'\n                ]);\n                this.pushSource(this.appendToBuffer(this.popStack()));\n            } else {\n                let local = this.popStack();\n                this.pushSource([\n                    'if (',\n                    local,\n                    ' != null) { ',\n                    this.appendToBuffer(local, undefined, true),\n                    ' }'\n                ]);\n                if (this.environment.isSimple) {\n                    this.pushSource([\n                        'else { ',\n                        this.appendToBuffer(\"''\", undefined, true),\n                        ' }'\n                    ]);\n                }\n            }\n        },\n        appendEscaped: function () {\n            this.pushSource(this.appendToBuffer([\n                this.aliasable('container.escapeExpression'),\n                '(',\n                this.popStack(),\n                ')'\n            ]));\n        },\n        getContext: function (depth) {\n            this.lastContext = depth;\n        },\n        pushContext: function () {\n            this.pushStackLiteral(this.contextName(this.lastContext));\n        },\n        lookupOnContext: function (parts, falsy, strict, scoped) {\n            let i = 0;\n            if (!scoped && this.options.compat && !this.lastContext) {\n                this.push(this.depthedLookup(parts[i++]));\n            } else {\n                this.pushContext();\n            }\n            this.resolvePath('context', parts, i, falsy, strict);\n        },\n        lookupBlockParam: function (blockParamId, parts) {\n            this.useBlockParams = true;\n            this.push([\n                'blockParams[',\n                blockParamId[0],\n                '][',\n                blockParamId[1],\n                ']'\n            ]);\n            this.resolvePath('context', parts, 1);\n        },\n        lookupData: function (depth, parts, strict) {\n            if (!depth) {\n                this.pushStackLiteral('data');\n            } else {\n                this.pushStackLiteral('container.data(data, ' + depth + ')');\n            }\n            this.resolvePath('data', parts, 0, true, strict);\n        },\n        resolvePath: function (type, parts, i, falsy, strict) {\n            if (this.options.strict || this.options.assumeObjects) {\n                this.push(strictLookup(this.options.strict && strict, this, parts, type));\n                return;\n            }\n            let len = parts.length;\n            for (; i < len; i++) {\n                this.replaceStack(current => {\n                    let lookup = this.nameLookup(current, parts[i], type);\n                    if (!falsy) {\n                        return [\n                            ' != null ? ',\n                            lookup,\n                            ' : ',\n                            current\n                        ];\n                    } else {\n                        return [\n                            ' && ',\n                            lookup\n                        ];\n                    }\n                });\n            }\n        },\n        resolvePossibleLambda: function () {\n            this.push([\n                this.aliasable('container.lambda'),\n                '(',\n                this.popStack(),\n                ', ',\n                this.contextName(0),\n                ')'\n            ]);\n        },\n        pushStringParam: function (string, type) {\n            this.pushContext();\n            this.pushString(type);\n            if (type !== 'SubExpression') {\n                if (typeof string === 'string') {\n                    this.pushString(string);\n                } else {\n                    this.pushStackLiteral(string);\n                }\n            }\n        },\n        emptyHash: function (omitEmpty) {\n            if (this.trackIds) {\n                this.push('{}');\n            }\n            if (this.stringParams) {\n                this.push('{}');\n                this.push('{}');\n            }\n            this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');\n        },\n        pushHash: function () {\n            if (this.hash) {\n                this.hashes.push(this.hash);\n            }\n            this.hash = {\n                values: {},\n                types: [],\n                contexts: [],\n                ids: []\n            };\n        },\n        popHash: function () {\n            let hash = this.hash;\n            this.hash = this.hashes.pop();\n            if (this.trackIds) {\n                this.push(this.objectLiteral(hash.ids));\n            }\n            if (this.stringParams) {\n                this.push(this.objectLiteral(hash.contexts));\n                this.push(this.objectLiteral(hash.types));\n            }\n            this.push(this.objectLiteral(hash.values));\n        },\n        pushString: function (string) {\n            this.pushStackLiteral(this.quotedString(string));\n        },\n        pushLiteral: function (value) {\n            this.pushStackLiteral(value);\n        },\n        pushProgram: function (guid) {\n            if (guid != null) {\n                this.pushStackLiteral(this.programExpression(guid));\n            } else {\n                this.pushStackLiteral(null);\n            }\n        },\n        registerDecorator(paramSize, name) {\n            let foundDecorator = this.nameLookup('decorators', name, 'decorator'), options = this.setupHelperArgs(name, paramSize);\n            this.decorators.push([\n                'fn = ',\n                this.decorators.functionCall(foundDecorator, '', [\n                    'fn',\n                    'props',\n                    'container',\n                    options\n                ]),\n                ' || fn;'\n            ]);\n        },\n        invokeHelper: function (paramSize, name, isSimple) {\n            let nonHelper = this.popStack(), helper = this.setupHelper(paramSize, name);\n            let possibleFunctionCalls = [];\n            if (isSimple) {\n                possibleFunctionCalls.push(helper.name);\n            }\n            possibleFunctionCalls.push(nonHelper);\n            if (!this.options.strict) {\n                possibleFunctionCalls.push(this.aliasable('container.hooks.helperMissing'));\n            }\n            let functionLookupCode = [\n                '(',\n                this.itemsSeparatedBy(possibleFunctionCalls, '||'),\n                ')'\n            ];\n            let functionCall = this.source.functionCall(functionLookupCode, 'call', helper.callParams);\n            this.push(functionCall);\n        },\n        itemsSeparatedBy: function (items, separator) {\n            let result = [];\n            result.push(items[0]);\n            for (let i = 1; i < items.length; i++) {\n                result.push(separator, items[i]);\n            }\n            return result;\n        },\n        invokeKnownHelper: function (paramSize, name) {\n            let helper = this.setupHelper(paramSize, name);\n            this.push(this.source.functionCall(helper.name, 'call', helper.callParams));\n        },\n        invokeAmbiguous: function (name, helperCall) {\n            this.useRegister('helper');\n            let nonHelper = this.popStack();\n            this.emptyHash();\n            let helper = this.setupHelper(0, name, helperCall);\n            let helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');\n            let lookup = [\n                '(',\n                '(helper = ',\n                helperName,\n                ' || ',\n                nonHelper,\n                ')'\n            ];\n            if (!this.options.strict) {\n                lookup[0] = '(helper = ';\n                lookup.push(' != null ? helper : ', this.aliasable('container.hooks.helperMissing'));\n            }\n            this.push([\n                '(',\n                lookup,\n                helper.paramsInit ? [\n                    '),(',\n                    helper.paramsInit\n                ] : [],\n                '),',\n                '(typeof helper === ',\n                this.aliasable('\"function\"'),\n                ' ? ',\n                this.source.functionCall('helper', 'call', helper.callParams),\n                ' : helper))'\n            ]);\n        },\n        invokePartial: function (isDynamic, name, indent) {\n            let params = [], options = this.setupParams(name, 1, params);\n            if (isDynamic) {\n                name = this.popStack();\n                delete options.name;\n            }\n            if (indent) {\n                options.indent = JSON.stringify(indent);\n            }\n            options.helpers = 'helpers';\n            options.partials = 'partials';\n            options.decorators = 'container.decorators';\n            if (!isDynamic) {\n                params.unshift(this.nameLookup('partials', name, 'partial'));\n            } else {\n                params.unshift(name);\n            }\n            if (this.options.compat) {\n                options.depths = 'depths';\n            }\n            options = this.objectLiteral(options);\n            params.push(options);\n            this.push(this.source.functionCall('container.invokePartial', '', params));\n        },\n        assignToHash: function (key) {\n            let value = this.popStack(), context, type, id;\n            if (this.trackIds) {\n                id = this.popStack();\n            }\n            if (this.stringParams) {\n                type = this.popStack();\n                context = this.popStack();\n            }\n            let hash = this.hash;\n            if (context) {\n                hash.contexts[key] = context;\n            }\n            if (type) {\n                hash.types[key] = type;\n            }\n            if (id) {\n                hash.ids[key] = id;\n            }\n            hash.values[key] = value;\n        },\n        pushId: function (type, name, child) {\n            if (type === 'BlockParam') {\n                this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));\n            } else if (type === 'PathExpression') {\n                this.pushString(name);\n            } else if (type === 'SubExpression') {\n                this.pushStackLiteral('true');\n            } else {\n                this.pushStackLiteral('null');\n            }\n        },\n        compiler: JavaScriptCompiler,\n        compileChildren: function (environment, options) {\n            let children = environment.children, child, compiler;\n            for (let i = 0, l = children.length; i < l; i++) {\n                child = children[i];\n                compiler = new this.compiler();\n                let existing = this.matchExistingProgram(child);\n                if (existing == null) {\n                    this.context.programs.push('');\n                    let index = this.context.programs.length;\n                    child.index = index;\n                    child.name = 'program' + index;\n                    this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);\n                    this.context.decorators[index] = compiler.decorators;\n                    this.context.environments[index] = child;\n                    this.useDepths = this.useDepths || compiler.useDepths;\n                    this.useBlockParams = this.useBlockParams || compiler.useBlockParams;\n                    child.useDepths = this.useDepths;\n                    child.useBlockParams = this.useBlockParams;\n                } else {\n                    child.index = existing.index;\n                    child.name = 'program' + existing.index;\n                    this.useDepths = this.useDepths || existing.useDepths;\n                    this.useBlockParams = this.useBlockParams || existing.useBlockParams;\n                }\n            }\n        },\n        matchExistingProgram: function (child) {\n            for (let i = 0, len = this.context.environments.length; i < len; i++) {\n                let environment = this.context.environments[i];\n                if (environment && environment.equals(child)) {\n                    return environment;\n                }\n            }\n        },\n        programExpression: function (guid) {\n            let child = this.environment.children[guid], programParams = [\n                    child.index,\n                    'data',\n                    child.blockParams\n                ];\n            if (this.useBlockParams || this.useDepths) {\n                programParams.push('blockParams');\n            }\n            if (this.useDepths) {\n                programParams.push('depths');\n            }\n            return 'container.program(' + programParams.join(', ') + ')';\n        },\n        useRegister: function (name) {\n            if (!this.registers[name]) {\n                this.registers[name] = true;\n                this.registers.list.push(name);\n            }\n        },\n        push: function (expr) {\n            if (!(expr instanceof Literal)) {\n                expr = this.source.wrap(expr);\n            }\n            this.inlineStack.push(expr);\n            return expr;\n        },\n        pushStackLiteral: function (item) {\n            this.push(new Literal(item));\n        },\n        pushSource: function (source) {\n            if (this.pendingContent) {\n                this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));\n                this.pendingContent = undefined;\n            }\n            if (source) {\n                this.source.push(source);\n            }\n        },\n        replaceStack: function (callback) {\n            let prefix = ['('], stack, createdStack, usedLiteral;\n            if (!this.isInline()) {\n                throw new Exception('replaceStack on non-inline');\n            }\n            let top = this.popStack(true);\n            if (top instanceof Literal) {\n                stack = [top.value];\n                prefix = [\n                    '(',\n                    stack\n                ];\n                usedLiteral = true;\n            } else {\n                createdStack = true;\n                let name = this.incrStack();\n                prefix = [\n                    '((',\n                    this.push(name),\n                    ' = ',\n                    top,\n                    ')'\n                ];\n                stack = this.topStack();\n            }\n            let item = callback.call(this, stack);\n            if (!usedLiteral) {\n                this.popStack();\n            }\n            if (createdStack) {\n                this.stackSlot--;\n            }\n            this.push(prefix.concat(item, ')'));\n        },\n        incrStack: function () {\n            this.stackSlot++;\n            if (this.stackSlot > this.stackVars.length) {\n                this.stackVars.push('stack' + this.stackSlot);\n            }\n            return this.topStackName();\n        },\n        topStackName: function () {\n            return 'stack' + this.stackSlot;\n        },\n        flushInline: function () {\n            let inlineStack = this.inlineStack;\n            this.inlineStack = [];\n            for (let i = 0, len = inlineStack.length; i < len; i++) {\n                let entry = inlineStack[i];\n                if (entry instanceof Literal) {\n                    this.compileStack.push(entry);\n                } else {\n                    let stack = this.incrStack();\n                    this.pushSource([\n                        stack,\n                        ' = ',\n                        entry,\n                        ';'\n                    ]);\n                    this.compileStack.push(stack);\n                }\n            }\n        },\n        isInline: function () {\n            return this.inlineStack.length;\n        },\n        popStack: function (wrapped) {\n            let inline = this.isInline(), item = (inline ? this.inlineStack : this.compileStack).pop();\n            if (!wrapped && item instanceof Literal) {\n                return item.value;\n            } else {\n                if (!inline) {\n                    if (!this.stackSlot) {\n                        throw new Exception('Invalid stack pop');\n                    }\n                    this.stackSlot--;\n                }\n                return item;\n            }\n        },\n        topStack: function () {\n            let stack = this.isInline() ? this.inlineStack : this.compileStack, item = stack[stack.length - 1];\n            if (item instanceof Literal) {\n                return item.value;\n            } else {\n                return item;\n            }\n        },\n        contextName: function (context) {\n            if (this.useDepths && context) {\n                return 'depths[' + context + ']';\n            } else {\n                return 'depth' + context;\n            }\n        },\n        quotedString: function (str) {\n            return this.source.quotedString(str);\n        },\n        objectLiteral: function (obj) {\n            return this.source.objectLiteral(obj);\n        },\n        aliasable: function (name) {\n            let ret = this.aliases[name];\n            if (ret) {\n                ret.referenceCount++;\n                return ret;\n            }\n            ret = this.aliases[name] = this.source.wrap(name);\n            ret.aliasable = true;\n            ret.referenceCount = 1;\n            return ret;\n        },\n        setupHelper: function (paramSize, name, blockHelper) {\n            let params = [], paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);\n            let foundHelper = this.nameLookup('helpers', name, 'helper'), callContext = this.aliasable(`${ this.contextName(0) } != null ? ${ this.contextName(0) } : (container.nullContext || {})`);\n            return {\n                params: params,\n                paramsInit: paramsInit,\n                name: foundHelper,\n                callParams: [callContext].concat(params)\n            };\n        },\n        setupParams: function (helper, paramSize, params) {\n            let options = {}, contexts = [], types = [], ids = [], objectArgs = !params, param;\n            if (objectArgs) {\n                params = [];\n            }\n            options.name = this.quotedString(helper);\n            options.hash = this.popStack();\n            if (this.trackIds) {\n                options.hashIds = this.popStack();\n            }\n            if (this.stringParams) {\n                options.hashTypes = this.popStack();\n                options.hashContexts = this.popStack();\n            }\n            let inverse = this.popStack(), program = this.popStack();\n            if (program || inverse) {\n                options.fn = program || 'container.noop';\n                options.inverse = inverse || 'container.noop';\n            }\n            let i = paramSize;\n            while (i--) {\n                param = this.popStack();\n                params[i] = param;\n                if (this.trackIds) {\n                    ids[i] = this.popStack();\n                }\n                if (this.stringParams) {\n                    types[i] = this.popStack();\n                    contexts[i] = this.popStack();\n                }\n            }\n            if (objectArgs) {\n                options.args = this.source.generateArray(params);\n            }\n            if (this.trackIds) {\n                options.ids = this.source.generateArray(ids);\n            }\n            if (this.stringParams) {\n                options.types = this.source.generateArray(types);\n                options.contexts = this.source.generateArray(contexts);\n            }\n            if (this.options.data) {\n                options.data = 'data';\n            }\n            if (this.useBlockParams) {\n                options.blockParams = 'blockParams';\n            }\n            return options;\n        },\n        setupHelperArgs: function (helper, paramSize, params, useRegister) {\n            let options = this.setupParams(helper, paramSize, params);\n            options.loc = JSON.stringify(this.source.currentLocation);\n            options = this.objectLiteral(options);\n            if (useRegister) {\n                this.useRegister('options');\n                params.push('options');\n                return [\n                    'options=',\n                    options\n                ];\n            } else if (params) {\n                params.push(options);\n                return '';\n            } else {\n                return options;\n            }\n        }\n    };\n    (function () {\n        const reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');\n        const compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};\n        for (let i = 0, l = reservedWords.length; i < l; i++) {\n            compilerWords[reservedWords[i]] = true;\n        }\n    }());\n    JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {\n        return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);\n    };\n    function strictLookup(requireTerminal, compiler, parts, type) {\n        let stack = compiler.popStack(), i = 0, len = parts.length;\n        if (requireTerminal) {\n            len--;\n        }\n        for (; i < len; i++) {\n            stack = compiler.nameLookup(stack, parts[i], type);\n        }\n        if (requireTerminal) {\n            return [\n                compiler.aliasable('container.strict'),\n                '(',\n                stack,\n                ', ',\n                compiler.quotedString(parts[i]),\n                ', ',\n                JSON.stringify(compiler.source.currentLocation),\n                ' )'\n            ];\n        } else {\n            return stack;\n        }\n    }\n    return JavaScriptCompiler;\n});\ndefine('skylark-handlebars/main',[\n    \"skylark-langx/skylark\",\n    './base',\n    \"./utils\",\n    \"./runtime\",\n    \"./exception\",\n    \"./safe-string\",\n    './compiler/ast',\n    './compiler/base',\n    './compiler/compiler',\n    './compiler/javascript-compiler',\n    './compiler/visitor'\n\n], function (skylark, base, Utils,runtime,Exception,SafeString, AST,cbase, compiler, JavaScriptCompiler, Visitor) {\n    'use strict';\n\n    function create() {\n        let hb = new base.HandlebarsEnvironment();\n        Utils.extend(hb, base);\n        hb.SafeString = SafeString;\n        hb.Exception = Exception;\n        hb.Utils = Utils;\n        hb.escapeExpression = Utils.escapeExpression;\n        hb.VM = runtime;\n\n        hb.template = function (spec) {\n            return runtime.template(spec, hb);\n        };\n\n        hb.compile = function (input, options) {\n            return compiler.compile(input, options, hb);\n        };\n\n        hb.precompile = function (input, options) {\n            return compiler.precompile(input, options, hb);\n        };\n        \n        hb.AST = AST;\n        hb.Compiler = compiler.Compiler;\n        hb.JavaScriptCompiler = JavaScriptCompiler;\n        hb.Parser = cbase.Parser;\n        hb.parse = cbase.parse;\n        hb.parseWithoutProcessing = base.parseWithoutProcessing;\n        return hb;\n    }\n    let inst = create();\n    inst.create = create;\n    inst.Visitor = Visitor;\n\n    return skylark.attach(\"intg.handlebars\",inst);\n});\ndefine('skylark-handlebars', ['skylark-handlebars/main'], function (main) { return main; });\n\n"]}