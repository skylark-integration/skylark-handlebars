{"version":3,"sources":["compiler/compiler.js"],"names":["define","Exception","utils","AST","slice","Compiler","argEquals","a","b","isArray","length","i","transformLiteralToPath","sexpr","path","parts","literal","type","data","depth","original","loc","prototype","compiler","equals","other","len","this","opcodes","opcode","otherOpcode","args","children","guid","compile","program","options","sourceNode","stringParams","trackIds","blockParams","knownHelpers","extend","Object","create","helperMissing","blockHelperMissing","each","if","unless","with","log","lookup","accept","compileProgram","result","usePartial","useDepths","node","unshift","ret","shift","Program","body","bodyLength","isSimple","BlockStatement","block","inverse","classifySexpr","helperSexpr","simpleSexpr","ambiguousSexpr","[object Object]","decorator","params","setupFullMustacheParams","undefined","useDecorators","PartialStatement","partial","explicitPartialContext","push","partialName","name","isDynamic","indent","preventIndent","PartialBlockStatement","partialBlock","MustacheStatement","mustache","SubExpression","escaped","noEscape","DecoratorBlock","ContentStatement","content","value","CommentStatement","isBlock","strict","knownHelpersOnly","falsy","helpers","simpleId","PathExpression","addDepth","scoped","scopedId","blockParamId","blockParamIndex","StringLiteral","string","NumberLiteral","number","BooleanLiteral","bool","UndefinedLiteral","NullLiteral","Hash","hash","pairs","l","pushParam","key","call","arguments","isBlockParam","isHelper","helperExpression","isEligible","pushParams","val","replace","blockParamChild","join","omitEmpty","param","indexOf","precompile","input","env","compat","ast","parse","environment","JavaScriptCompiler","compiled","compileInput","templateSpec","template","context","execOptions","_setup","setupOptions","_child","depths"],"mappings":"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","file":"../../compiler/compiler.js","sourcesContent":["define([\n    '../exception',\n    '../utils',\n    './ast'\n], function (Exception, utils, AST) {\n    'use strict';\n    const slice = [].slice;\n    function Compiler() {\n    }\n    Compiler.prototype = {\n        compiler: Compiler,\n        equals: function (other) {\n            let len = this.opcodes.length;\n            if (other.opcodes.length !== len) {\n                return false;\n            }\n            for (let i = 0; i < len; i++) {\n                let opcode = this.opcodes[i], otherOpcode = other.opcodes[i];\n                if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {\n                    return false;\n                }\n            }\n            len = this.children.length;\n            for (let i = 0; i < len; i++) {\n                if (!this.children[i].equals(other.children[i])) {\n                    return false;\n                }\n            }\n            return true;\n        },\n        guid: 0,\n        compile: function (program, options) {\n            this.sourceNode = [];\n            this.opcodes = [];\n            this.children = [];\n            this.options = options;\n            this.stringParams = options.stringParams;\n            this.trackIds = options.trackIds;\n            options.blockParams = options.blockParams || [];\n            options.knownHelpers = utils.extend(Object.create(null), {\n                helperMissing: true,\n                blockHelperMissing: true,\n                each: true,\n                if: true,\n                unless: true,\n                with: true,\n                log: true,\n                lookup: true\n            }, options.knownHelpers);\n            return this.accept(program);\n        },\n        compileProgram: function (program) {\n            let childCompiler = new this.compiler(), result = childCompiler.compile(program, this.options), guid = this.guid++;\n            this.usePartial = this.usePartial || result.usePartial;\n            this.children[guid] = result;\n            this.useDepths = this.useDepths || result.useDepths;\n            return guid;\n        },\n        accept: function (node) {\n            if (!this[node.type]) {\n                throw new Exception('Unknown type: ' + node.type, node);\n            }\n            this.sourceNode.unshift(node);\n            let ret = this[node.type](node);\n            this.sourceNode.shift();\n            return ret;\n        },\n        Program: function (program) {\n            this.options.blockParams.unshift(program.blockParams);\n            let body = program.body, bodyLength = body.length;\n            for (let i = 0; i < bodyLength; i++) {\n                this.accept(body[i]);\n            }\n            this.options.blockParams.shift();\n            this.isSimple = bodyLength === 1;\n            this.blockParams = program.blockParams ? program.blockParams.length : 0;\n            return this;\n        },\n        BlockStatement: function (block) {\n            transformLiteralToPath(block);\n            let program = block.program, inverse = block.inverse;\n            program = program && this.compileProgram(program);\n            inverse = inverse && this.compileProgram(inverse);\n            let type = this.classifySexpr(block);\n            if (type === 'helper') {\n                this.helperSexpr(block, program, inverse);\n            } else if (type === 'simple') {\n                this.simpleSexpr(block);\n                this.opcode('pushProgram', program);\n                this.opcode('pushProgram', inverse);\n                this.opcode('emptyHash');\n                this.opcode('blockValue', block.path.original);\n            } else {\n                this.ambiguousSexpr(block, program, inverse);\n                this.opcode('pushProgram', program);\n                this.opcode('pushProgram', inverse);\n                this.opcode('emptyHash');\n                this.opcode('ambiguousBlockValue');\n            }\n            this.opcode('append');\n        },\n        DecoratorBlock(decorator) {\n            let program = decorator.program && this.compileProgram(decorator.program);\n            let params = this.setupFullMustacheParams(decorator, program, undefined), path = decorator.path;\n            this.useDecorators = true;\n            this.opcode('registerDecorator', params.length, path.original);\n        },\n        PartialStatement: function (partial) {\n            this.usePartial = true;\n            let program = partial.program;\n            if (program) {\n                program = this.compileProgram(partial.program);\n            }\n            let params = partial.params;\n            if (params.length > 1) {\n                throw new Exception('Unsupported number of partial arguments: ' + params.length, partial);\n            } else if (!params.length) {\n                if (this.options.explicitPartialContext) {\n                    this.opcode('pushLiteral', 'undefined');\n                } else {\n                    params.push({\n                        type: 'PathExpression',\n                        parts: [],\n                        depth: 0\n                    });\n                }\n            }\n            let partialName = partial.name.original, isDynamic = partial.name.type === 'SubExpression';\n            if (isDynamic) {\n                this.accept(partial.name);\n            }\n            this.setupFullMustacheParams(partial, program, undefined, true);\n            let indent = partial.indent || '';\n            if (this.options.preventIndent && indent) {\n                this.opcode('appendContent', indent);\n                indent = '';\n            }\n            this.opcode('invokePartial', isDynamic, partialName, indent);\n            this.opcode('append');\n        },\n        PartialBlockStatement: function (partialBlock) {\n            this.PartialStatement(partialBlock);\n        },\n        MustacheStatement: function (mustache) {\n            this.SubExpression(mustache);\n            if (mustache.escaped && !this.options.noEscape) {\n                this.opcode('appendEscaped');\n            } else {\n                this.opcode('append');\n            }\n        },\n        Decorator(decorator) {\n            this.DecoratorBlock(decorator);\n        },\n        ContentStatement: function (content) {\n            if (content.value) {\n                this.opcode('appendContent', content.value);\n            }\n        },\n        CommentStatement: function () {\n        },\n        SubExpression: function (sexpr) {\n            transformLiteralToPath(sexpr);\n            let type = this.classifySexpr(sexpr);\n            if (type === 'simple') {\n                this.simpleSexpr(sexpr);\n            } else if (type === 'helper') {\n                this.helperSexpr(sexpr);\n            } else {\n                this.ambiguousSexpr(sexpr);\n            }\n        },\n        ambiguousSexpr: function (sexpr, program, inverse) {\n            let path = sexpr.path, name = path.parts[0], isBlock = program != null || inverse != null;\n            this.opcode('getContext', path.depth);\n            this.opcode('pushProgram', program);\n            this.opcode('pushProgram', inverse);\n            path.strict = true;\n            this.accept(path);\n            this.opcode('invokeAmbiguous', name, isBlock);\n        },\n        simpleSexpr: function (sexpr) {\n            let path = sexpr.path;\n            path.strict = true;\n            this.accept(path);\n            this.opcode('resolvePossibleLambda');\n        },\n        helperSexpr: function (sexpr, program, inverse) {\n            let params = this.setupFullMustacheParams(sexpr, program, inverse), path = sexpr.path, name = path.parts[0];\n            if (this.options.knownHelpers[name]) {\n                this.opcode('invokeKnownHelper', params.length, name);\n            } else if (this.options.knownHelpersOnly) {\n                throw new Exception('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);\n            } else {\n                path.strict = true;\n                path.falsy = true;\n                this.accept(path);\n                this.opcode('invokeHelper', params.length, path.original, AST.helpers.simpleId(path));\n            }\n        },\n        PathExpression: function (path) {\n            this.addDepth(path.depth);\n            this.opcode('getContext', path.depth);\n            let name = path.parts[0], scoped = AST.helpers.scopedId(path), blockParamId = !path.depth && !scoped && this.blockParamIndex(name);\n            if (blockParamId) {\n                this.opcode('lookupBlockParam', blockParamId, path.parts);\n            } else if (!name) {\n                this.opcode('pushContext');\n            } else if (path.data) {\n                this.options.data = true;\n                this.opcode('lookupData', path.depth, path.parts, path.strict);\n            } else {\n                this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);\n            }\n        },\n        StringLiteral: function (string) {\n            this.opcode('pushString', string.value);\n        },\n        NumberLiteral: function (number) {\n            this.opcode('pushLiteral', number.value);\n        },\n        BooleanLiteral: function (bool) {\n            this.opcode('pushLiteral', bool.value);\n        },\n        UndefinedLiteral: function () {\n            this.opcode('pushLiteral', 'undefined');\n        },\n        NullLiteral: function () {\n            this.opcode('pushLiteral', 'null');\n        },\n        Hash: function (hash) {\n            let pairs = hash.pairs, i = 0, l = pairs.length;\n            this.opcode('pushHash');\n            for (; i < l; i++) {\n                this.pushParam(pairs[i].value);\n            }\n            while (i--) {\n                this.opcode('assignToHash', pairs[i].key);\n            }\n            this.opcode('popHash');\n        },\n        opcode: function (name) {\n            this.opcodes.push({\n                opcode: name,\n                args: slice.call(arguments, 1),\n                loc: this.sourceNode[0].loc\n            });\n        },\n        addDepth: function (depth) {\n            if (!depth) {\n                return;\n            }\n            this.useDepths = true;\n        },\n        classifySexpr: function (sexpr) {\n            let isSimple = AST.helpers.simpleId(sexpr.path);\n            let isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);\n            let isHelper = !isBlockParam && AST.helpers.helperExpression(sexpr);\n            let isEligible = !isBlockParam && (isHelper || isSimple);\n            if (isEligible && !isHelper) {\n                let name = sexpr.path.parts[0], options = this.options;\n                if (options.knownHelpers[name]) {\n                    isHelper = true;\n                } else if (options.knownHelpersOnly) {\n                    isEligible = false;\n                }\n            }\n            if (isHelper) {\n                return 'helper';\n            } else if (isEligible) {\n                return 'ambiguous';\n            } else {\n                return 'simple';\n            }\n        },\n        pushParams: function (params) {\n            for (let i = 0, l = params.length; i < l; i++) {\n                this.pushParam(params[i]);\n            }\n        },\n        pushParam: function (val) {\n            let value = val.value != null ? val.value : val.original || '';\n            if (this.stringParams) {\n                if (value.replace) {\n                    value = value.replace(/^(\\.?\\.\\/)*/g, '').replace(/\\//g, '.');\n                }\n                if (val.depth) {\n                    this.addDepth(val.depth);\n                }\n                this.opcode('getContext', val.depth || 0);\n                this.opcode('pushStringParam', value, val.type);\n                if (val.type === 'SubExpression') {\n                    this.accept(val);\n                }\n            } else {\n                if (this.trackIds) {\n                    let blockParamIndex;\n                    if (val.parts && !AST.helpers.scopedId(val) && !val.depth) {\n                        blockParamIndex = this.blockParamIndex(val.parts[0]);\n                    }\n                    if (blockParamIndex) {\n                        let blockParamChild = val.parts.slice(1).join('.');\n                        this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);\n                    } else {\n                        value = val.original || value;\n                        if (value.replace) {\n                            value = value.replace(/^this(?:\\.|$)/, '').replace(/^\\.\\//, '').replace(/^\\.$/, '');\n                        }\n                        this.opcode('pushId', val.type, value);\n                    }\n                }\n                this.accept(val);\n            }\n        },\n        setupFullMustacheParams: function (sexpr, program, inverse, omitEmpty) {\n            let params = sexpr.params;\n            this.pushParams(params);\n            this.opcode('pushProgram', program);\n            this.opcode('pushProgram', inverse);\n            if (sexpr.hash) {\n                this.accept(sexpr.hash);\n            } else {\n                this.opcode('emptyHash', omitEmpty);\n            }\n            return params;\n        },\n        blockParamIndex: function (name) {\n            for (let depth = 0, len = this.options.blockParams.length; depth < len; depth++) {\n                let blockParams = this.options.blockParams[depth], param = blockParams && utils.indexOf(blockParams, name);\n                if (blockParams && param >= 0) {\n                    return [\n                        depth,\n                        param\n                    ];\n                }\n            }\n        }\n    };\n    function precompile(input, options, env) {\n        if (input == null || typeof input !== 'string' && input.type !== 'Program') {\n            throw new Exception('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);\n        }\n        options = options || {};\n        if (!('data' in options)) {\n            options.data = true;\n        }\n        if (options.compat) {\n            options.useDepths = true;\n        }\n        let ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options);\n        return new env.JavaScriptCompiler().compile(environment, options);\n    }\n    function compile(input, options = {}, env) {\n        if (input == null || typeof input !== 'string' && input.type !== 'Program') {\n            throw new Exception('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);\n        }\n        options = utils.extend({}, options);\n        if (!('data' in options)) {\n            options.data = true;\n        }\n        if (options.compat) {\n            options.useDepths = true;\n        }\n        let compiled;\n        function compileInput() {\n            let ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options), templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);\n            return env.template(templateSpec);\n        }\n        function ret(context, execOptions) {\n            if (!compiled) {\n                compiled = compileInput();\n            }\n            return compiled.call(this, context, execOptions);\n        }\n        ret._setup = function (setupOptions) {\n            if (!compiled) {\n                compiled = compileInput();\n            }\n            return compiled._setup(setupOptions);\n        };\n        ret._child = function (i, data, blockParams, depths) {\n            if (!compiled) {\n                compiled = compileInput();\n            }\n            return compiled._child(i, data, blockParams, depths);\n        };\n        return ret;\n    }\n    function argEquals(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (utils.isArray(a) && utils.isArray(b) && a.length === b.length) {\n            for (let i = 0; i < a.length; i++) {\n                if (!argEquals(a[i], b[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    function transformLiteralToPath(sexpr) {\n        if (!sexpr.path.parts) {\n            let literal = sexpr.path;\n            sexpr.path = {\n                type: 'PathExpression',\n                data: false,\n                depth: 0,\n                parts: [literal.original + ''],\n                original: literal.original + '',\n                loc: literal.loc\n            };\n        }\n    }\n    return {\n        Compiler: Compiler,\n        precompile: precompile,\n        compile: compile\n    };\n});"]}