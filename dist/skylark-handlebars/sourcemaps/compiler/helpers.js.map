{"version":3,"sources":["compiler/helpers.js"],"names":["define","Exception","validateClose","open","close","path","original","errorNode","loc","SourceLocation","source","locInfo","this","start","line","first_line","column","first_column","end","last_line","last_column","id","token","test","substring","length","stripFlags","charAt","stripComment","comment","replace","preparePath","data","parts","dig","depth","i","l","part","isLiteral","separator","push","type","prepareMustache","params","hash","strip","escapeFlag","escaped","prepareRawBlock","openRawBlock","contents","program","body","openStrip","inverseStrip","closeStrip","prepareBlock","openBlock","inverseAndProgram","inverted","inverse","decorator","blockParams","chain","prepareProgram","statements","firstLoc","lastLoc","preparePartialBlock","name"],"mappings":"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","file":"../../compiler/helpers.js","sourcesContent":["define(['../exception'], function (Exception) {\n    'use strict';\n    function validateClose(open, close) {\n        close = close.path ? close.path.original : close;\n        if (open.path.original !== close) {\n            let errorNode = { loc: open.path.loc };\n            throw new Exception(open.path.original + \" doesn't match \" + close, errorNode);\n        }\n    }\n    function SourceLocation(source, locInfo) {\n        this.source = source;\n        this.start = {\n            line: locInfo.first_line,\n            column: locInfo.first_column\n        };\n        this.end = {\n            line: locInfo.last_line,\n            column: locInfo.last_column\n        };\n    }\n    function id(token) {\n        if (/^\\[.*\\]$/.test(token)) {\n            return token.substring(1, token.length - 1);\n        } else {\n            return token;\n        }\n    }\n    function stripFlags(open, close) {\n        return {\n            open: open.charAt(2) === '~',\n            close: close.charAt(close.length - 3) === '~'\n        };\n    }\n    function stripComment(comment) {\n        return comment.replace(/^\\{\\{~?!-?-?/, '').replace(/-?-?~?\\}\\}$/, '');\n    }\n    function preparePath(data, parts, loc) {\n        loc = this.locInfo(loc);\n        let original = data ? '@' : '', dig = [], depth = 0;\n        for (let i = 0, l = parts.length; i < l; i++) {\n            let part = parts[i].part, isLiteral = parts[i].original !== part;\n            original += (parts[i].separator || '') + part;\n            if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {\n                if (dig.length > 0) {\n                    throw new Exception('Invalid path: ' + original, { loc });\n                } else if (part === '..') {\n                    depth++;\n                }\n            } else {\n                dig.push(part);\n            }\n        }\n        return {\n            type: 'PathExpression',\n            data,\n            depth,\n            parts: dig,\n            original,\n            loc\n        };\n    }\n    function prepareMustache(path, params, hash, open, strip, locInfo) {\n        let escapeFlag = open.charAt(3) || open.charAt(2), escaped = escapeFlag !== '{' && escapeFlag !== '&';\n        let decorator = /\\*/.test(open);\n        return {\n            type: decorator ? 'Decorator' : 'MustacheStatement',\n            path,\n            params,\n            hash,\n            escaped,\n            strip,\n            loc: this.locInfo(locInfo)\n        };\n    }\n    function prepareRawBlock(openRawBlock, contents, close, locInfo) {\n        validateClose(openRawBlock, close);\n        locInfo = this.locInfo(locInfo);\n        let program = {\n            type: 'Program',\n            body: contents,\n            strip: {},\n            loc: locInfo\n        };\n        return {\n            type: 'BlockStatement',\n            path: openRawBlock.path,\n            params: openRawBlock.params,\n            hash: openRawBlock.hash,\n            program,\n            openStrip: {},\n            inverseStrip: {},\n            closeStrip: {},\n            loc: locInfo\n        };\n    }\n    function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {\n        if (close && close.path) {\n            validateClose(openBlock, close);\n        }\n        let decorator = /\\*/.test(openBlock.open);\n        program.blockParams = openBlock.blockParams;\n        let inverse, inverseStrip;\n        if (inverseAndProgram) {\n            if (decorator) {\n                throw new Exception('Unexpected inverse block on decorator', inverseAndProgram);\n            }\n            if (inverseAndProgram.chain) {\n                inverseAndProgram.program.body[0].closeStrip = close.strip;\n            }\n            inverseStrip = inverseAndProgram.strip;\n            inverse = inverseAndProgram.program;\n        }\n        if (inverted) {\n            inverted = inverse;\n            inverse = program;\n            program = inverted;\n        }\n        return {\n            type: decorator ? 'DecoratorBlock' : 'BlockStatement',\n            path: openBlock.path,\n            params: openBlock.params,\n            hash: openBlock.hash,\n            program,\n            inverse,\n            openStrip: openBlock.strip,\n            inverseStrip,\n            closeStrip: close && close.strip,\n            loc: this.locInfo(locInfo)\n        };\n    }\n    function prepareProgram(statements, loc) {\n        if (!loc && statements.length) {\n            const firstLoc = statements[0].loc, lastLoc = statements[statements.length - 1].loc;\n            if (firstLoc && lastLoc) {\n                loc = {\n                    source: firstLoc.source,\n                    start: {\n                        line: firstLoc.start.line,\n                        column: firstLoc.start.column\n                    },\n                    end: {\n                        line: lastLoc.end.line,\n                        column: lastLoc.end.column\n                    }\n                };\n            }\n        }\n        return {\n            type: 'Program',\n            body: statements,\n            strip: {},\n            loc: loc\n        };\n    }\n    function preparePartialBlock(open, program, close, locInfo) {\n        validateClose(open, close);\n        return {\n            type: 'PartialBlockStatement',\n            name: open.path,\n            params: open.params,\n            hash: open.hash,\n            program,\n            openStrip: open.strip,\n            closeStrip: close && close.strip,\n            loc: this.locInfo(locInfo)\n        };\n    }\n    return {\n        SourceLocation: SourceLocation,\n        id: id,\n        stripFlags: stripFlags,\n        stripComment: stripComment,\n        preparePath: preparePath,\n        prepareMustache: prepareMustache,\n        prepareRawBlock: prepareRawBlock,\n        prepareBlock: prepareBlock,\n        prepareProgram: prepareProgram,\n        preparePartialBlock: preparePartialBlock\n    };\n});"]}