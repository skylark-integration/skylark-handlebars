{"version":3,"sources":["compiler/whitespace-control.js"],"names":["define","Visitor","WhitespaceControl","options","this","isPrevWhitespace","body","i","isRoot","undefined","length","prev","sibling","type","test","original","isNextWhitespace","next","omitRight","multiple","current","rightStripped","value","replace","omitLeft","leftStripped","prototype","Program","program","doStandalone","ignoreStandalone","isRootSeen","l","strip","accept","_isPrevWhitespace","_isNextWhitespace","openStandalone","closeStandalone","inlineStandalone","close","open","indent","exec","inverse","BlockStatement","DecoratorBlock","PartialBlockStatement","block","firstInverse","lastInverse","chained","openStrip","closeStrip","inverseStrip","Decorator","MustacheStatement","mustache","PartialStatement","CommentStatement","node"],"mappings":"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","file":"../../compiler/whitespace-control.js","sourcesContent":["define(['./visitor'], function (Visitor) {\n    'use strict';\n    function WhitespaceControl(options = {}) {\n        this.options = options;\n    }\n    WhitespaceControl.prototype = new Visitor();\n    WhitespaceControl.prototype.Program = function (program) {\n        const doStandalone = !this.options.ignoreStandalone;\n        let isRoot = !this.isRootSeen;\n        this.isRootSeen = true;\n        let body = program.body;\n        for (let i = 0, l = body.length; i < l; i++) {\n            let current = body[i], strip = this.accept(current);\n            if (!strip) {\n                continue;\n            }\n            let _isPrevWhitespace = isPrevWhitespace(body, i, isRoot), _isNextWhitespace = isNextWhitespace(body, i, isRoot), openStandalone = strip.openStandalone && _isPrevWhitespace, closeStandalone = strip.closeStandalone && _isNextWhitespace, inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;\n            if (strip.close) {\n                omitRight(body, i, true);\n            }\n            if (strip.open) {\n                omitLeft(body, i, true);\n            }\n            if (doStandalone && inlineStandalone) {\n                omitRight(body, i);\n                if (omitLeft(body, i)) {\n                    if (current.type === 'PartialStatement') {\n                        current.indent = /([ \\t]+$)/.exec(body[i - 1].original)[1];\n                    }\n                }\n            }\n            if (doStandalone && openStandalone) {\n                omitRight((current.program || current.inverse).body);\n                omitLeft(body, i);\n            }\n            if (doStandalone && closeStandalone) {\n                omitRight(body, i);\n                omitLeft((current.inverse || current.program).body);\n            }\n        }\n        return program;\n    };\n    WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {\n        this.accept(block.program);\n        this.accept(block.inverse);\n        let program = block.program || block.inverse, inverse = block.program && block.inverse, firstInverse = inverse, lastInverse = inverse;\n        if (inverse && inverse.chained) {\n            firstInverse = inverse.body[0].program;\n            while (lastInverse.chained) {\n                lastInverse = lastInverse.body[lastInverse.body.length - 1].program;\n            }\n        }\n        let strip = {\n            open: block.openStrip.open,\n            close: block.closeStrip.close,\n            openStandalone: isNextWhitespace(program.body),\n            closeStandalone: isPrevWhitespace((firstInverse || program).body)\n        };\n        if (block.openStrip.close) {\n            omitRight(program.body, null, true);\n        }\n        if (inverse) {\n            let inverseStrip = block.inverseStrip;\n            if (inverseStrip.open) {\n                omitLeft(program.body, null, true);\n            }\n            if (inverseStrip.close) {\n                omitRight(firstInverse.body, null, true);\n            }\n            if (block.closeStrip.open) {\n                omitLeft(lastInverse.body, null, true);\n            }\n            if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {\n                omitLeft(program.body);\n                omitRight(firstInverse.body);\n            }\n        } else if (block.closeStrip.open) {\n            omitLeft(program.body, null, true);\n        }\n        return strip;\n    };\n    WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {\n        return mustache.strip;\n    };\n    WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {\n        let strip = node.strip || {};\n        return {\n            inlineStandalone: true,\n            open: strip.open,\n            close: strip.close\n        };\n    };\n    function isPrevWhitespace(body, i, isRoot) {\n        if (i === undefined) {\n            i = body.length;\n        }\n        let prev = body[i - 1], sibling = body[i - 2];\n        if (!prev) {\n            return isRoot;\n        }\n        if (prev.type === 'ContentStatement') {\n            return (sibling || !isRoot ? /\\r?\\n\\s*?$/ : /(^|\\r?\\n)\\s*?$/).test(prev.original);\n        }\n    }\n    function isNextWhitespace(body, i, isRoot) {\n        if (i === undefined) {\n            i = -1;\n        }\n        let next = body[i + 1], sibling = body[i + 2];\n        if (!next) {\n            return isRoot;\n        }\n        if (next.type === 'ContentStatement') {\n            return (sibling || !isRoot ? /^\\s*?\\r?\\n/ : /^\\s*?(\\r?\\n|$)/).test(next.original);\n        }\n    }\n    function omitRight(body, i, multiple) {\n        let current = body[i == null ? 0 : i + 1];\n        if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {\n            return;\n        }\n        let original = current.value;\n        current.value = current.value.replace(multiple ? /^\\s+/ : /^[ \\t]*\\r?\\n?/, '');\n        current.rightStripped = current.value !== original;\n    }\n    function omitLeft(body, i, multiple) {\n        let current = body[i == null ? body.length - 1 : i - 1];\n        if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {\n            return;\n        }\n        let original = current.value;\n        current.value = current.value.replace(multiple ? /\\s+$/ : /[ \\t]+$/, '');\n        current.leftStripped = current.value !== original;\n        return current.leftStripped;\n    }\n    return WhitespaceControl;\n});"]}